# 项目中遇到的问题及解决思路

## 一、解决过多if-else的问题

通常是使用策略模式或工厂模式来解决，但是弊端就是如果有很多if-else就需要创建很多的类，所以在项目中使用了Map加Function接口的方式来结局if-else的问题，代码如下：

```java
public class ServicelImpl {

    static FunctionImpl function = new FunctionImpl();
    //如果需要传两个参数即(sn1,sn2)->{}的形式，可以使用BiFunction
    static Map<Integer, Function<String,String>> map = new HashMap();

    private static void Init(){
        map.put(5,sn->function.func1((String) sn));
        map.put(6,sn->function.func1((String) sn));
        map.put(7,sn->function.func1((String) sn));
    }

    public static void pullTask(String sn){
        //根据sn查询任务
        int taskType =5 ;//数据库查询出来的任务类型
        Function<String,String> function = map.get(taskType);
        Object apply = function.apply(sn);
        System.out.println(apply);

    }

    public static void main(String[] args) {
        Init();
        pullTask("123");
    }

}
```

```java
public class FunctionImpl {

    public String func1(String str1){
        //do
        return str1;
    }
    public String func2(String str1){
        //do
        return str1;
    }
    public String func3(String str1){
        //do
        return str1;
    }
}
```

思路就是，将策略模式中的策略存入Function，在业务中使用时，只需要调用init()初始化这个Map或者使用`@PostConstruct`，然后就不需要额外每次多一种类型都需要在下面在加一个if-else。

> 被`@PostConstruct`修饰的方法会在加载servlet的时候运行，且只会被执行一次。类似于Servlet的`init()`方法。被`@PostConstruct`修饰的方法会在构造方法之后，`init()`方法之前运行。
>
> 类似的注解还有`@PreConstruct`，被`@PreConstruct`修饰的方法在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的`destroy()`方法，被`@PreConstruct`修饰的方法会在`destroy()`方法之后运行，在Servlet被彻底卸载之前。

## 二、检查APK签名版本

在需要判断apk签名版本时可以使用如下方法：

可以在powershell中，进入到sdk的路径，如下：

` cd C:\Users\XXX\AppData\Local\Android\Sdk\build-tools\27.0.3`

然后在此文件夹中执行命令：

` .\apksigner verify -v xxx.apk`

即可检查apk签名的版本是V1还是V2

## 三、安卓端通过命令启动应用

安卓端可以通过`adb shell am start -n package/launch_activity`

其中上述的package是该app的包名，launch_actity是该app的主Activity（需要全限定类型，即包名+类名），可以通过打开该APP然后使用命令`adb shell dumpsys window windows|findstr current`来获取主Activity的类名。

## 四、Spring手动回滚事务

应用场景是当我们需要对业务层进行try-catch时，上层无法获取我们的异常，所以@Transactional无法进行回滚，这时需要我们在catch中手动回滚或者在抛出异常。

```java
TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
```

## 五、排除数据库依赖

除了要排除`DataSourceAutoConfiguration`还应该排除`DruidDataSourceAutoConfigure`。因为有的依赖还是用了Druid数据库

```java
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class, DruidDataSourceAutoConfigure.class,})
```

## 六、mysql instr函数

函数语法:

`INSTR（str,substr） / instr(源字符串, 目标字符串)`

参数说明：

str：从哪个字符串中搜索；

substr:要搜索的子字符串。

例如：INSTR('apple','a')，返回的查询结果是1，因为a出现在字符串‘apple’中的第一个索引；

业务场景：查询一个表中的字段是否包含另一个表中的字段

## 七、mysql REGEXP（mysql正则）

Whether string matches regular expression 字符串是否匹配正则，官方文档用法示例：

~~~mysql
mysql> SELECT 'Michael!' REGEXP '.*';
+------------------------+
| 'Michael!' REGEXP '.*' |
+------------------------+
|                      1 |
+------------------------+
mysql> SELECT 'new*\n*line' REGEXP 'new\\*.\\*line';
+---------------------------------------+
| 'new*\n*line' REGEXP 'new\\*.\\*line' |
+---------------------------------------+
|                                     0 |
+---------------------------------------+
mysql> SELECT 'a' REGEXP '^[a-d]';
+---------------------+
| 'a' REGEXP '^[a-d]' |
+---------------------+
|                   1 |
+---------------------+
~~~

Returns 1 if the string *`expr`* matches the regular expression specified by the pattern *`pat`*, 0 otherwise. If *`expr`* or *`pat`* is `NULL`, the return value is `NULL`.

如果正则匹配则返回1，否则返回0

在业务中的用法：

`r.buildVersion REGEXP CONCAT(l.version,'$')`

业务场景：需要匹配一个表中的字段是否在另一个表中出现且在最后

这里使用了concat进行了字段拼接，保证了正则和字段属性能形成一个大正则。

## 八、AndroidStudio下载问题

创建或build安卓项目时，有时会一直卡在某一个jar包的下载上，这时候可以通过配置阿里的源来解决，注意如果是7.0以下的gradle版本需要在build.gradle文件中配置：

> 注意配置maven仓库时如果是http的地址需要加上这句：allowInsecureProtocol = true

```
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    repositories {
    maven {
            allowInsecureProtocol = true
            url 'http://maven.aliyun.com/nexus/content/groups/public'}
        google()
        mavenCentral()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:4.1.1"
        classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.10'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}
allprojects {
    repositories {
        // maven { url 'https://maven.google.com' }
        maven {
            allowInsecureProtocol = true
            url 'http://maven.aliyun.com/nexus/content/groups/public'}
        jcenter()
        mavenCentral()
    }
}
task clean(type: Delete) {
    delete rootProject.buildDir
}
```

注意如果是7.0以上的gradle版本需要在settings.gradle文件中配置：

```
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        maven {
            allowInsecureProtocol = true
            url 'http://maven.aliyun.com/nexus/content/groups/public'}
        google()
        mavenCentral()
        jcenter() // Warning: this repository is going to shut down soon
    }
}
rootProject.name = "HelloWorld"
include ':app'
```

## 九、linux排查各文件夹的大小

遇到系统磁盘满了的情况可以使用以下命令逐一排查是哪个地方用量过大,其中--max-depth表示遍历深度或者说是目录层数，一般设置为1即可。

`du -h --max-depth=1`

## 十、SpringBoot手动管理事务

有时可能需要手动管理事务，方法如下：

```java
@Autowired
private PlatformTransactionManager platformTransactionManager;

@Autowired
private TransactionDefinition transactionDefinition;

public void test(){
    TransactionStatus transaction = platformTransactionManager.getTransaction(transactionDefinition);
    try{
        //......业务
        platformTransactionManager.commit(transaction);
    }catch (Exception e){
        platformTransactionManager.rollback(transaction);
    }
}
```

## 十一、MySQL的COLLATE导致不区分大小写

当我们搜索时发现MySQL对大小写不敏感，同时设置中也设置了严格区分大小写（0代表严格区分, 1代表不区分），如下图：

![image-20220804151905192](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220804151905192.png)

问题如下，有这么一条数据：

![image-20220804151714797](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220804151714797.png)

我们现在搜索它发现，这个数据不区分大小写

![image-20220804152002171](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220804152002171.png)

这个问题其实是因为MySQL的COLLATE（排序规则）造成的。COLLATE默认是与数据编码CHARSET相关的，一般来说每种CHARSET都指定一种COLLATE为默认值，比如Latin1编码的默认COLLATE为latin1_swedish_ci;比如utf8mb4的默认值为utf8mb4_general_ci。

很多COLLATE都带有ci字样，这是Case Insensitive的缩写，即大小写无关，也就是说”A”和”a”在排序和比较的时候是一视同仁的。select * from table1 where field1=”a”同样可以把field1为”A”的值选出来。与此同时，对于那些cs后缀的COLLATE，则是Case Sensitive，即大小写敏感的。

**collate规则**：

-  bin: 表示的是binary case sensitive collation，也就是说是区分大小写的
-  cs: case sensitive collation，区分大小写
-  ci: case insensitive collation，不区分大小写

> 我们可以用show collation查看mysql支持的所有COLLATE

因此回到此问题我们可以通过两种方式解决：

1. 可以将查询条件用binary()括起来。 比如上面sql语句改成这样`SELECT * FROM `user_info` where BINARY name = 'ZHANGSAN'` 

2. 将COLLATE修改为bin类型。比如`ALTER` `TABLE` `TABLENAME ``MODIFY` `COLUMN` `COLUMNNAME ``VARCHAR``(50) ``BINARY` `CHARACTER` `SET` `utf8 ``COLLATE` `utf8_bin ``DEFAULT` `NULL``;`

   又或者用navicat修改排序规则都可以

   ![image-20220804153010008](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220804153010008.png)

> 原理：
>
> 对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的 校对规则。BINARY属性是指定列字符集的二元 校对规则的简写。排序和比较基于数值字符值。因此也就自然区分了大小写。

## 十二、SpringBoot接口实现类切换

业务场景是这样的，不同的平台部署项目的接口实现需要不一样。比如A平台部署时需要我们的项目向OSS中上传文件，B平台部署时需要用MinIO作文件服务器，针对这种不同的情况我们可以使用`@ConditionalOnProperty`注解进行标注，其中value指的是配置文件中的key，havingValue表示配置文件中的值，如果配置文件中数据满足此值，那么就注入这个实现类。

举个例子，现在有个FileService接口，A客户要用OSS作服务器，B客户要用MinIO做服务器，我们就可以在实现类上进行标注：

```java
@ConditionalOnProperty(value = "file.type", havingValue = "oss")
@Service
public class FileServiceOssImpl implements FileService{}

@ConditionalOnProperty(value = "file.type", havingValue = "minio")
@Service
public class FileServiceMinIOImpl implements FileService{}
```

然后在配置文件中指定要注入哪个配置类：

~~~properties
#A客户
file.type=oss
#B客户
#file.type=minio
~~~

## 十三、jdbc时区切换

jdbc的URL中可以用serverTimezone指定时区，一般可以使用`serverTimezone=Asia/Shanghai`指定上海时间，如果向指定某一时区的时间可以用GMT标准时间指定，比如南非的时区在东二区所以其时区是：`serverTimezone=GMT%2B2`或北京在东八区其时区为：`serverTimezone=GMT%2B8`

## 十四、Nginx反向代理使用域名的缓存问题

~~~nginx
location /something {
            proxy_pass http://www.demo.com;	
        }
~~~

nginx反向代理使用域名时，nginx只会根据启动时从服务器获取的解析IP进行代理，直到下一次nginx重启，或者reload，因此当某个ip挂掉了之后可能就会一直访问不上，并报502等错误。解决方案就是重启nginx或reload nginx。

## 十五、唯一键索引和逻辑删除冲突的问题

逻辑删除和唯一性索引同时存在的情况下，已经逻辑删除的数据由于唯一性索引的约束无法再次添加。

这时可以将逻辑删除字段也加入唯一性索引就可以解决此问题。但是这样又多了新的问题就是再次添加同样的数据时无法进行删除。

此时可以通过将逻辑删除字段在删除时不设置为false或1等常规数据，而是通过主键id或当前时间戳代表被删除的数据，这样就可以完美解决此问题。

但是主键id或时间戳可能会很长，所以**可以通过置空的方式表示被删除的数据**，这种方式是目前来说最完美的解决方案了。

> mybatisplus中更新时字段为null的话是不会更新的，因此可以用`@TableField(updateStrategy = FieldStrategy.IGNORED)`让该字段更新时忽略null，这样就可以将null插入到数据库了。
