# 设计模式学习文档

转载请声明，禁止抄袭，请珍惜他人成果，本文中如有错误欢迎各位大佬指正，感激不尽。

> 未完结

以Java为例，参考资料：设计模式之禅，重学Java设计模式，菜鸟教程

学习设计模式，可以提高代码的可重用性，增强系统的可维护性，我在学习Spring等框架的源码时，在业务过于复杂且不知道如何改进时，都会深感自己的设计模式学习的不够深入，因此我会在空闲时间，结合书本和自身实践进行学习，学习设计模式并整理文档。

## 一、设计原则

### 单一职责原则

英文名称是`Single Responsibility Principle`，简称是SRP。这句话的定义是：`There should never be more than one reasonfor a class to change.`翻译过来就是一个类变化的原因不应该超过一个。

举个例子：定义一个任务接口

~~~java
public interface IAnimal{
    public void eat();
    public void run();
    public void sex();
}
~~~

此接口有三个职责，分别是进食（生存）、奔跑（行动）和繁衍，一个动物确实应该有这些职责，但是单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情，但是上面的接口并不是这样。我们可以这样修改：

~~~java
public class Animal implements ISurvival,IAction,IMultiply{
    
}
~~~

这样的设计才是完美的，一个类实现了三个接口，把三个职责融合在一个类中。

通过上面的例子，我们来总结一下单一职责原则有什么好处：类的复杂性降低，实现什么职责都有清晰明确的定义；可读性提高，复杂性降低；可维护性提高，可读性提高，那当然更容易维护了；变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

当然，实际生产中生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。所以原则是死的，人是活的。

### 里氏替换原则

在面向对象的语言中，继承是非常优秀的语言机制，但是有优点必然也有缺点，继承也是如此，继承有如下缺点“

- 代码是侵入性的，只要继承，就必须有父类的属性和方法；
- 降低了代码的灵活性，子类必须有父类的属性和方法
- 增加了耦合性。当父类的变量常量和方法被修改时，需要考虑子类的修改，在缺乏规范的情况下，大段代码需要重构。

总之，继承从整体上看利大于弊，怎么减少弊带来的麻烦呢？这时就需要引入里氏替换原则。它有两种定义：
~~~
第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype ofT.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）
第二种定义：Functions that use pointers or references to base classes mustbe able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）
~~~
说人话就是只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行。

里氏替换原则（LSP）为良好的继承定义了一个规范，一句简单的定义包含了4层含义。

1. 子类必须完全实现父类的方法

   ![LSP20220318](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/LSP20220318.png)

   在平时开发时，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里已经使用了里氏替换原则。我们举个例子来说明。如上图（上面的类的实现略，简单实现即可），军队都陆海空三种具体的部队实现，在将军类中定义了一个方法派兵，通过军队发起进攻，具体派什么部队，调用的时候才知道。测试代码如下：

   ~~~java
   public class Test{
       public static void main(Sting[] args){
           General general = new General();
           general.setArmy(new Navy());
           general.dispatchTroops();
       }
   }
   ~~~

   在这个程序中，我们给将军一个军队，然后就可以派遣军队了。如果将军要派遣不同的军队，只需要在setArmy中更换即可，在编写程序时将军类根本就不用知道是那个类型的部队（子类）被传入。

   > 在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。

   但是如果这时出现了文艺兵部队（`LiteraryAndArtTroops`），也继承军队类，但是如果将军在设置军队时设置的文艺兵部队，就出现了问题，因为文艺兵本来就不是打仗的。这时我们可以使用`instanceof`来进行判断，但是如果有更多的子类就会造成业务过于复杂。这时我们可以通过让文艺兵部队也继承一个父类（比如后勤部队），然后`instanceof`这个父类就行了。如下图：

   ![LSP220220318](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/LSP220220318.png)

2. 子类可以有自己的个性

   子类当然可以有自己方法和属性，但是里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。比如上面的例子。如果在子类出现的地方强转成弗雷德类型，则会在运行期抛出`java.lang.ClassCastException`异常，这也是常说的向下转型（downcast）是不安全的，从里氏替换原则来看，就是有子类出现的地方父类未必就可以出现。

3. 覆盖或实现父类的方法时输入参数可以被放大

   举个例子：下面是子类对父类的重载（Overload）而不是重写（Override），因为方法名相同参数不同。（不在一个类也可以重载）

   ```java
   public class Father {
       public Collection doSomething(HashMap map){
           System.out.println("father do..");
           return map.values();
       }
   }
   ```

   ```java
   public class Son extends Father{
   
       public Collection doSomething(Map map) {
           System.out.println("son do...");
           return map.values();
       }
   }
   ```

   ```java
   public class Test {
       public static void main(String[] args) {
           Father father =new Father();
           HashMap map = new HashMap();
           father.doSomething(map);
           //父类出现的地方子类也可以出现
           Son son = new Son();
           son.doSomething(map);
       }
   }
   ```

   执行结果为：

   ~~~
   father do..
   father do..
   ~~~

   结果竟然一样。父类方法的输入参数是HashMap类型，子类的输入参数是Map类型，也就是说子类的输入参数类型的范围扩大了，子类代替父类传递到调用者中，子类的方法永远都不会被执行，这是正确的。因为如果Father类的输入参数类型宽于子类的输入参数类型，会出现父类存在的地方，子类就未必可以存在。比如我们将Father和Son类的doSomething方法的参数调换再次运行，这时运行结果会变成这样：

   ~~~
   father do..
   son do...
   ~~~

   子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱。所以子类中方法的前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松。

4. 覆写或实现父类的方法时输出结果可以被缩小

   跟上面类似。父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。

在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！

### 依赖倒置原则

依赖倒置原则的原始定义是：High level modules should not depend upon low level modules.Bothshould depend upon abstractions.Abstractions should not depend upondetails.Details should depend upon abstractions.

翻译过来，包含三层含义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。更精简的解释就是面向接口编程。

采用依赖倒置原则（DIP）可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

我们可以通过例子来了解依赖倒置：比如下面的代码我们让驾驶员去开宝马汽车

~~~java
public class Driver{
    public void drive(BWM bwm){
        bwn.run();
    }
}
public class BWM{
    public void run (BWM bwm){
       System.out.println("宝马汽车开始启动...");
    }
}
public class Test{
    public static void main(String[] args){
        Driver driver = new Driver();
        BWM bwm = new BWM();
        driver.drive(bwm);
    }
}
~~~

但这时候如果需要驾驶员开QQ汽车又该怎么办呢。这时我们会发现驾驶员没有办法开QQ汽车了，因为他没有开QQ汽车的方法。

因此，针对上面的情况，我们可以采用依赖倒置原则，也就是面向接口开发，我们只需要引入驾驶员和汽车的接口即可。如下面代码：

~~~java
public interface IDriver{
    void drive(ICar car);
}
public interface ICar{
    void run();
}
public class Test{
    public static void main(String[] args){
        Driver driver = new Driver();
        ICar car = new BWM();
        driver.drive(car);
    }
}
~~~

这时如果驾驶员要开其他类型的汽车也很好办，只需要更换不同的实现类即可。在IDriver中，通过传入ICar接口实现了抽象之间的依赖关系，Driver实现类也传入了ICar 接口，至于到底是哪个型号的Car，需要在高层模块中声明。在新增加低层模块时，只修改了业务场景类，也就是高层模块（在例子中就是Test类），对其他低层模块如 Driver类不需要做任何修改，业务就可以运行，把“变更”引起的风险扩散降到最低。

依赖是可以传递的，主要有三种方式：

1. 构造函数
2. set方法
3. 接口声明依赖的对象（这种方式就是上面我们例子中的形式）

### 接口隔离原则

接口隔离有两种定义：

~~~
 1.Clients should not be forced to depend upon interfaces that they don't use.
 客户端不要应该依赖不需要的接口
 2.The dependency of one class to another one should depend on the smallest possible interface
 类间的依赖关系应该建立在最小的接口上
~~~

说人话就是接口应该单一且尽量细化即接口中的方法尽量少。

注意这与单一职责原则是不同的，单一职责是在业务上的的划分，即要求类和接口职责尽量单一，而接口隔离原则则要求接口的方法尽量少。举例子讲：如果有一个接口的职责有20个方法，他提供给多个模块访问，单一职责是允许的，但是接口隔离原则是不允许的。因为他需要尽量多使用专门的接口，也就是给几个模块用就应该有几个接口，而不是有一个庞大的接口给所有的客户端使用。

我们举个例子：比如现在我作为星探需要寻找偶像，现在我规定几个我寻找偶像的条件

~~~java
public interface IIdol {
    public void goodLooking();
    public void canSign();
    public void canDance();
}
public class Idol implements IIdol{

    @Override
    public void goodLooking() {
        System.out.println("好看");
    }

    @Override
    public void canSign() {
        System.out.println("能唱歌");
    }

    @Override
    public void canDance() {
        System.out.println("能跳舞");
    }
}
~~~

然后我定义一个星探：

```java
public abstract class AbstractSearcher {
    protected IIdol iIdol;

    public AbstractSearcher(IIdol iIdol) {
        this.iIdol = iIdol;
    }

    public abstract void showYouSelf();
}
public class Searcher extends AbstractSearcher {
    public Searcher(IIdol iIdol) {
        super(iIdol);
    }

    @Override
    public void showYouSelf() {
        iIdol.goodLooking();
        iIdol.canDance();
        iIdol.canSign();
    }
}
public class Test {
    public static void main(String[] args) {
        IIdol idol = new Idol();
        AbstractSearcher searcher = new Searcher(idol);
        searcher.showYouSelf();
    }
}
```

以上我们能很好的找到我们想要的idol候选人，但是我们找idol的标准肯定也在变化，比如我想要一个身材好的偶像，我想要一个能唱跳的偶像，这时我们会发现我们的偶像接口是有缺陷的，过于庞大，这时根据接口隔离原则，我们分析星探可以按照特质寻找偶像，我们重新设计一下类图：

![interface120220321](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/interface120220321.png)

我们得寻找外在内在条件都符合的人做idol。这样把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。

接口隔离原则是对接口进行规范约束，其包含以下4层含义：

1. 接口尽量小

2. 接口要高内聚

   高内聚就是提高接口、类、模块的处理能力，减少对外的交互。要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。

3. 定制服务

   我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求：只提供访问者需要的方法。比如我有个创建任务的接口，对于管理员或者普通用户能创建的任务类型必然是不同的，那么我们就可以针对管理员或者普通用户定制接口，比如创建管理员任务就放在管理员的接口中，创建普通任务就放在普通用户创建任务的接口中。

4. 接口设计是有限度的

   接口的设计粒度越小，系统越灵活，但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，因此实际项目中，莫要过度设计。

### 迪米特法则

迪米特法则（Law of Demeter，LoD）也称为最少知识原则，即一个对象应该对其他对象有最少的了解。

说人话就是你内部有多复杂我都不管，但是我只关心你暴露出来的，即public的方法。

### 开闭原则



## 二、设计模式

