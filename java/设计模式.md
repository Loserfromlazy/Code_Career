# 设计模式学习文档

转载请声明，禁止抄袭，请珍惜他人成果，本文中如有错误欢迎各位大佬指正，感激不尽。

> 未完结

以Java为例，参考资料：设计模式之禅，重学Java设计模式，菜鸟教程

学习设计模式，可以提高代码的可重用性，增强系统的可维护性，我在学习Spring等框架的源码时，在业务过于复杂且不知道如何改进时，都会深感自己的设计模式学习的不够深入，因此我会在空闲时间，结合书本和自身实践进行学习，学习设计模式并整理文档。

## 一、设计原则

### 单一职责原则

英文名称是`Single Responsibility Principle`，简称是SRP。这句话的定义是：`There should never be more than one reasonfor a class to change.`翻译过来就是一个类变化的原因不应该超过一个。

举个例子：定义一个动物接口

~~~java
public interface IAnimal{
    public void eat();
    public void run();
    public void sex();
}
~~~

此接口有三个职责，分别是进食（生存）、奔跑（行动）和繁衍，一个动物确实应该有这些职责，但是单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情，但是上面的接口并不是这样。我们可以这样修改：

~~~java
public class Animal implements ISurvival,IAction,IMultiply{
    
}
~~~

这样的设计才是完美的，一个类实现了三个接口，把三个职责融合在一个类中。

通过上面的例子，我们来总结一下单一职责原则有什么好处：类的复杂性降低，实现什么职责都有清晰明确的定义；可读性提高，复杂性降低；可维护性提高，可读性提高，那当然更容易维护了；变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

当然，实际生产中生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。所以原则是死的，人是活的。

### 里氏替换原则

在面向对象的语言中，继承是非常优秀的语言机制，但是有优点必然也有缺点，继承也是如此，继承有如下缺点“

- 代码是侵入性的，只要继承，就必须有父类的属性和方法；
- 降低了代码的灵活性，子类必须有父类的属性和方法
- 增加了耦合性。当父类的变量常量和方法被修改时，需要考虑子类的修改，在缺乏规范的情况下，大段代码需要重构。

总之，继承从整体上看利大于弊，怎么减少弊带来的麻烦呢？这时就需要引入里氏替换原则。它有两种定义：
~~~
第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype ofT.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）
第二种定义：Functions that use pointers or references to base classes mustbe able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）
~~~
说人话就是只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行。

里氏替换原则（LSP）为良好的继承定义了一个规范，一句简单的定义包含了4层含义。

1. 子类必须完全实现父类的方法

   ![LSP20220318](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/LSP20220318.png)

   在平时开发时，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里已经使用了里氏替换原则。我们举个例子来说明。如上图（上面的类的实现略，简单实现即可），军队都陆海空三种具体的部队实现，在将军类中定义了一个方法派兵，通过军队发起进攻，具体派什么部队，调用的时候才知道。测试代码如下：

   ~~~java
   public class Test{
       public static void main(Sting[] args){
           General general = new General();
           general.setArmy(new Navy());
           general.dispatchTroops();
       }
   }
   ~~~

   在这个程序中，我们给将军一个军队，然后就可以派遣军队了。如果将军要派遣不同的军队，只需要在setArmy中更换即可，在编写程序时将军类根本就不用知道是那个类型的部队（子类）被传入。

   > 在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。

   但是如果这时出现了文艺兵部队（`LiteraryAndArtTroops`），也继承军队类，但是如果将军在设置军队时设置的文艺兵部队，就出现了问题，因为文艺兵本来就不是打仗的。这时我们可以使用`instanceof`来进行判断，但是如果有更多的子类就会造成业务过于复杂。这时我们可以通过让文艺兵部队也继承一个父类（比如后勤部队），然后`instanceof`这个父类就行了。如下图：

   ![LSP220220318](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/LSP220220318.png)

2. 子类可以有自己的个性

   子类当然可以有自己方法和属性，但是里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。比如上面的例子。如果在子类出现的地方强转成弗雷德类型，则会在运行期抛出`java.lang.ClassCastException`异常，这也是常说的向下转型（downcast）是不安全的，从里氏替换原则来看，就是有子类出现的地方父类未必就可以出现。

3. 覆盖或实现父类的方法时输入参数可以被放大

   举个例子：下面是子类对父类的重载（Overload）而不是重写（Override），因为方法名相同参数不同。（不在一个类也可以重载）

   ```java
   public class Father {
       public Collection doSomething(HashMap map){
           System.out.println("father do..");
           return map.values();
       }
   }
   ```

   ```java
   public class Son extends Father{
   
       public Collection doSomething(Map map) {
           System.out.println("son do...");
           return map.values();
       }
   }
   ```

   ```java
   public class Test {
       public static void main(String[] args) {
           Father father =new Father();
           HashMap map = new HashMap();
           father.doSomething(map);
           //父类出现的地方子类也可以出现
           Son son = new Son();
           son.doSomething(map);
       }
   }
   ```

   执行结果为：

   ~~~
   father do..
   father do..
   ~~~

   结果竟然一样。父类方法的输入参数是HashMap类型，子类的输入参数是Map类型，也就是说子类的输入参数类型的范围扩大了，子类代替父类传递到调用者中，子类的方法永远都不会被执行，这是正确的。因为如果Father类的输入参数类型宽于子类的输入参数类型，会出现父类存在的地方，子类就未必可以存在。比如我们将Father和Son类的doSomething方法的参数调换再次运行，这时运行结果会变成这样：

   ~~~
   father do..
   son do...
   ~~~

   子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱。所以子类中方法的前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松。

4. 覆写或实现父类的方法时输出结果可以被缩小

   跟上面类似。父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。

在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！

### 依赖倒置原则

依赖倒置原则的原始定义是：High level modules should not depend upon low level modules.Bothshould depend upon abstractions.Abstractions should not depend upondetails.Details should depend upon abstractions.

翻译过来，包含三层含义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。更精简的解释就是面向接口编程。

采用依赖倒置原则（DIP）可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

我们可以通过例子来了解依赖倒置：比如下面的代码我们让驾驶员去开宝马汽车

~~~java
public class Driver{
    public void drive(BWM bwm){
        bwn.run();
    }
}
public class BWM{
    public void run (BWM bwm){
       System.out.println("宝马汽车开始启动...");
    }
}
public class Test{
    public static void main(String[] args){
        Driver driver = new Driver();
        BWM bwm = new BWM();
        driver.drive(bwm);
    }
}
~~~

但这时候如果需要驾驶员开QQ汽车又该怎么办呢。这时我们会发现驾驶员没有办法开QQ汽车了，因为他没有开QQ汽车的方法。

因此，针对上面的情况，我们可以采用依赖倒置原则，也就是面向接口开发，我们只需要引入驾驶员和汽车的接口即可。如下面代码：

~~~java
public interface IDriver{
    void drive(ICar car);
}
public interface ICar{
    void run();
}
public class Test{
    public static void main(String[] args){
        Driver driver = new Driver();
        ICar car = new BWM();
        driver.drive(car);
    }
}
~~~

这时如果驾驶员要开其他类型的汽车也很好办，只需要更换不同的实现类即可。在IDriver中，通过传入ICar接口实现了抽象之间的依赖关系，Driver实现类也传入了ICar 接口，至于到底是哪个型号的Car，需要在高层模块中声明。在新增加低层模块时，只修改了业务场景类，也就是高层模块（在例子中就是Test类），对其他低层模块如 Driver类不需要做任何修改，业务就可以运行，把“变更”引起的风险扩散降到最低。

依赖是可以传递的，主要有三种方式：

1. 构造函数
2. set方法
3. 接口声明依赖的对象（这种方式就是上面我们例子中的形式）

### 接口隔离原则

接口隔离有两种定义：

~~~
 1.Clients should not be forced to depend upon interfaces that they don't use.
 客户端不要应该依赖不需要的接口
 2.The dependency of one class to another one should depend on the smallest possible interface
 类间的依赖关系应该建立在最小的接口上
~~~

说人话就是接口应该单一且尽量细化即接口中的方法尽量少。

注意这与单一职责原则是不同的，单一职责是在业务上的的划分，即要求类和接口职责尽量单一，而接口隔离原则则要求接口的方法尽量少。举例子讲：如果有一个接口的职责有20个方法，他提供给多个模块访问，单一职责是允许的，但是接口隔离原则是不允许的。因为他需要尽量多使用专门的接口，也就是给几个模块用就应该有几个接口，而不是有一个庞大的接口给所有的客户端使用。

我们举个例子：比如现在我作为星探需要寻找偶像，现在我规定几个我寻找偶像的条件

~~~java
public interface IIdol {
    public void goodLooking();
    public void canSign();
    public void canDance();
}
public class Idol implements IIdol{

    @Override
    public void goodLooking() {
        System.out.println("好看");
    }

    @Override
    public void canSign() {
        System.out.println("能唱歌");
    }

    @Override
    public void canDance() {
        System.out.println("能跳舞");
    }
}
~~~

然后我定义一个星探：

```java
public abstract class AbstractSearcher {
    protected IIdol iIdol;

    public AbstractSearcher(IIdol iIdol) {
        this.iIdol = iIdol;
    }

    public abstract void showYouSelf();
}
public class Searcher extends AbstractSearcher {
    public Searcher(IIdol iIdol) {
        super(iIdol);
    }

    @Override
    public void showYouSelf() {
        iIdol.goodLooking();
        iIdol.canDance();
        iIdol.canSign();
    }
}
public class Test {
    public static void main(String[] args) {
        IIdol idol = new Idol();
        AbstractSearcher searcher = new Searcher(idol);
        searcher.showYouSelf();
    }
}
```

以上我们能很好的找到我们想要的idol候选人，但是我们找idol的标准肯定也在变化，比如我想要一个身材好的偶像，我想要一个能唱跳的偶像，这时我们会发现我们的偶像接口是有缺陷的，过于庞大，这时根据接口隔离原则，我们分析星探可以按照特质寻找偶像，我们重新设计一下类图：

![interface120220321](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/interface120220321.png)

我们得寻找外在内在条件都符合的人做idol。这样把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。

接口隔离原则是对接口进行规范约束，其包含以下4层含义：

1. 接口尽量小

2. 接口要高内聚

   高内聚就是提高接口、类、模块的处理能力，减少对外的交互。要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。

3. 定制服务

   我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求：只提供访问者需要的方法。比如我有个创建任务的接口，对于管理员或者普通用户能创建的任务类型必然是不同的，那么我们就可以针对管理员或者普通用户定制接口，比如创建管理员任务就放在管理员的接口中，创建普通任务就放在普通用户创建任务的接口中。

4. 接口设计是有限度的

   接口的设计粒度越小，系统越灵活，但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，因此实际项目中，莫要过度设计。

### 迪米特法则

迪米特法则（Law of Demeter，LoD）也称为最少知识原则，即一个对象应该对其他对象有最少的了解。

说人话就是你内部有多复杂我都不管，但是我只关心你暴露出来的，即public的方法。

了解迪米特法则就需要先了解朋友类，朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。

迪米特法则主要包含四层含义：

1. 只和朋友交流

   这里举个例子，如果老师想知道今天一共多少节课，那么它需要班长去统计今天的课程数。类图如下：

   ![dimite120220412](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/dimite120220412.png)

   这里给出代码实现：

   ```java
   public class Teacher {
       public void command(Monitor monitor){
           List<Course> list = new ArrayList<>();
           for (int i = 0; i < 20; i++) {
               list.add(new Course());
           }
           monitor.countCourse(list);
       }
   }
   public class Monitor {
       public void countCourse(List<Course> list){
           System.out.println(list.size());
       }
   }
   public class Course {
   }
   public class Test {
       public static void main(String[] args) {
           Teacher teacher =new Teacher();
           teacher.command(new Monitor());
       }
   }
   ```

   从上面的代码可以看出这段代码是违反迪米特法则的，因为Tercher类中有非朋友类的类Course类。我们应该做如下修改：

   ![image-20220412151721465](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220412151721465.png)

   ```java
   public class Teacher {
       public void command(Monitor monitor){
           monitor.countCourse();
       }
   }
   public class Monitor {
       private List<Course> list;
       public Monitor(List<Course> list) {
           this.list = list;
       }
       public void countCourse(){
           System.out.println(this.list.size());
       }
   }
   public class Course {
   }
   public class Test {
       public static void main(String[] args) {
           List<Course> list = new ArrayList<>();
           for (int i = 0; i < 20; i++) {
               list.add(new Course());
           }
           Teacher teacher =new Teacher();
           teacher.command(new Monitor(list));
       }
   }
   ```

   这样的话Tercher类就只和自己的朋友类沟通，不用和自己的非朋友类沟通。符合迪米特法则。

2. 朋友之间也是有距离的

   这个原则的含义就是不要暴露过多的方法给朋友类，言外之意就是不要过于耦合。

   这里给个例子：假如我们想报销就必须要走审核流程，那么用代码表示如下：

   ```java
   //审核流程
   public class ApprovalProcess {
       public void first(){
           System.out.println("first");
       }
       public void second(){
           System.out.println("second");
       }
       public void third(){
           System.out.println("third");
       }
   }
   //报销类
   public class Reimburse {
       public void examineAndApprove(ApprovalProcess approvalProcess){
           approvalProcess.first();
           approvalProcess.second();
           approvalProcess.third();
       }
   }
   public class TestApproval {
       public static void main(String[] args) {
           Reimburse reimburse = new Reimburse();
           reimburse.examineAndApprove(new ApprovalProcess());
       }
   }
   ```

   上面的这个类显然关系过于亲密，如果我们要修改审核流程不仅需要修改ApprovalProcess类，还需要修改Reimburse类的源码，这显然不够合理。我们跟第一个原则一样，进行一下重构，代码如下：

   ```java
   public class ApprovalProcess {
       public void first(){
           System.out.println("first");
       }
       public void second(){
           System.out.println("second");
       }
       public void third(){
           System.out.println("third");
       }
       //报销流程
       public void reimburseProcess(){
           first();
           second();
           third();
       }
   }
   public class Reimburse {
       public void examineAndApprove(ApprovalProcess approvalProcess){
           approvalProcess.reimburseProcess();
       }
   }
   ```

   这样修改后，不论怎么改报销的流程（比如去掉第二步增加第四步等等）都不需要修改审核类Reimburse的代码了。

3. 是自己的就是自己的

   如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。

4. 谨慎使用Serializable

迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。因此使用时应谨慎考虑，做到高内聚低耦合。

### 开闭原则

开闭原则是Java世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。

开闭原则的定义：

~~~
Software entities like classes,modules andfunctions should be open for extension butclosed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）
~~~

> 开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。

如果说上面五个原则是Java中的实现类，那么开闭原则就是他们的抽象类。也就是说开闭原则是一种精神领袖。那么我们如何使用开闭原则呢？

1. 抽象约束

   通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：第一，通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定，一旦确定即不允许修改。

   当然，我们还是通过例子来了解：

   我们这里直接借用设计模式之禅中的例子：现在有一个书店，目前只有小说，类图如下：

   ![image-20220412160406226](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220412160406226.png)

   以书店为例，目前只是销售小说类书籍，单一经营毕竟是有风险的，于是书店新增加了计算机书籍，它不仅包含书籍名称、作者、价格等信息，还有一个独特的属性：面向的是什么领域，也就是它的范围，比如是和编程语言相关的，还是和数据库相关的。我们现在进行修改：

   ![image-20220412160807848](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220412160807848.png)

   只要增加一个接口IComputerBook和实现类Computer- Book，而BookStore不用做任何修改就可以完成书店销售计算机书籍的业务。

   这时我们在BookStore的代码中只需要新增计算机书籍即可：

   ![image-20220412160857437](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220412160857437.png)

   首先，ComputerBook类必须实现IBook的三个方法，是通过IComputerBook接口传递进来的约束，也就是我们制定的IBook接口对扩展类ComputerBook产生了约束力，正是由于该约束力，BookStore类才不需要进行大量的修改。

   这种维护是很轻便的，但如果我们直接只定义了一个IBook实现类，那么要修改的地方将是很多的需要大返工。

2. 元数据控制

   如何能减轻我们的开发压力呢？答案是尽量使用元数据来控制程序的行为，减少重复开发。什么是元数据？用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。举个非常简单的例子，我们的项目需要调用其他项目的接口，这是我们就可以将接口地址存入配置文件，那么将来接口有变化我们就可以通过修改配置文件来完成业务的变化。

3. 指定项目章程

   在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。比如我们都约定开发时所有的Bean都必须继承指定父类，这样一旦成员都熟悉规则了后，开发的效率会更高。因为我们不再需要创建一些通用属性了比如ID（这里只是举个例子，实际项目肯定规则是不同的，需要在开发前就进行设计）

4. 封装变化

开闭原则是一个终极目标，任何人包括大师级人物都无法百分之百做到，但朝这个方向努力，可以非常显著地改善一个系统的架构，真正做到“拥抱变化”。

## 二、设计模式



## 创建者模式



## 结构型模式



## 行为模式









