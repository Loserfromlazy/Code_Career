# 设计模式学习文档

例子以Java为例

> 未完结

参考资料：设计模式之禅，重学Java设计模式

## 一、设计原则

### 单一职责原则

英文名称是`Single Responsibility Principle`，简称是SRP。这句话的定义是：`There should never be more than one reasonfor a class to change.`翻译过来就是一个类变化的原因不应该超过一个。

举个例子：定义一个任务接口

~~~java
public interface IAnimal{
    public void eat();
    public void run();
    public void sex();
}
~~~

此接口有三个职责，分别是进食（生存）、奔跑（行动）和繁衍，一个动物确实应该有这些职责，但是单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情，但是上面的接口并不是这样。我们可以这样修改：

~~~java
public class Animal implements ISurvival,IAction,IMultiply{
    
}
~~~

这样的设计才是完美的，一个类实现了三个接口，把三个职责融合在一个类中。

通过上面的例子，我们来总结一下单一职责原则有什么好处：类的复杂性降低，实现什么职责都有清晰明确的定义；可读性提高，复杂性降低；可维护性提高，可读性提高，那当然更容易维护了；变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

当然，实际生产中生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。里氏替换原则所以原则是死的，人是活的。

### 里氏替换原则

在面向对象的语言中，继承是非常优秀的语言机制，但是有优点必然也有缺点，继承也是如此，继承有如下缺点“

- 代码是侵入性的，只要继承，就必须有父类的属性和方法；
- 降低了代码的灵活性，子类必须有父类的属性和方法
- 增加了耦合性。当父类的变量常量和方法被修改时，需要考虑子类的修改，在缺乏规范的情况下，大段代码需要重构。

总之，继承从整体上看利大于弊，怎么减少弊带来的麻烦呢？这时就需要引入里氏替换原则。它有两种定义：
~~~
第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype ofT.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）
第二种定义：Functions that use pointers or references to base classes mustbe able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）
~~~
说人话就是只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行。

里氏替换原则（LSP）为良好的继承定义了一个规范，一句简单的定义包含了4层含义。

1. 子类必须完全实现父类的方法

   ![LSP20220318](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/LSP20220318.png)

   在平时开发时，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里已经使用了里氏替换原则。我们举个例子来说明。如上图（上面的类的实现略，简单实现即可），军队都陆海空三种具体的部队实现，在将军类中定义了一个方法派兵，通过军队发起进攻，具体派什么部队，调用的时候才知道。测试代码如下：

   ~~~java
   public class Test{
       public static void main(Sting[] args){
           General general = new General();
           general.setArmy(new Navy());
           general.dispatchTroops();
       }
   }
   ~~~

   在这个程序中，我们给将军一个军队，然后就可以派遣军队了。如果将军要派遣不同的军队，只需要在setArmy中更换即可，在编写程序时将军类根本就不用知道是那个类型的部队（子类）被传入。

   > 在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。

   但是如果这时出现了文艺兵部队（`LiteraryAndArtTroops`），也继承军队类，但是如果将军在设置军队时设置的文艺兵部队，就出现了问题，因为文艺兵本来就不是打仗的。这时我们可以使用`instanceof`来进行判断，但是如果有更多的子类就会造成业务过于复杂。这时我们可以通过让文艺兵部队也继承一个父类（比如后勤部队），然后`instanceof`这个父类就行了。如下图：

   ![LSP220220318](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/LSP220220318.png)

2. 子类可以有自己的个性

   子类当然可以有自己方法和属性，但是里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。比如上面的例子。如果在子类出现的地方强转成弗雷德类型，则会在运行期抛出`java.lang.ClassCastException`异常，这也是常说的向下转型（downcast）是不安全的，从里氏替换原则来看，就是有子类出现的地方父类未必就可以出现。

3. 覆盖或实现父类的方法时输入参数可以被放大

   举个例子：下面是子类对父类的重载（Overload）而不是重写（Override），因为方法名相同参数不同。（不在一个类也可以重载）

   ```java
   public class Father {
       public Collection doSomething(HashMap map){
           System.out.println("father do..");
           return map.values();
       }
   }
   ```

   ```java
   public class Son extends Father{
   
       public Collection doSomething(Map map) {
           System.out.println("son do...");
           return map.values();
       }
   }
   ```

   ```java
   public class Test {
       public static void main(String[] args) {
           Father father =new Father();
           HashMap map = new HashMap();
           father.doSomething(map);
           //父类出现的地方子类也可以出现
           Son son = new Son();
           son.doSomething(map);
       }
   }
   ```

   执行结果为：

   ~~~
   father do..
   father do..
   ~~~

   结果竟然一样。父类方法的输入参数是HashMap类型，子类的输入参数是Map类型，也就是说子类的输入参数类型的范围扩大了，子类代替父类传递到调用者中，子类的方法永远都不会被执行，这是正确的。因为如果Father类的输入参数类型宽于子类的输入参数类型，会出现父类存在的地方，子类就未必可以存在。比如我们将Father和Son类的doSomething方法的参数调换再次运行，这时运行结果会变成这样：

   ~~~
   father do..
   son do...
   ~~~

   子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱。所以子类中方法的前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松。

4. 覆写或实现父类的方法时输出结果可以被缩小

   跟上面类似。父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。

在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！

### 依赖倒置原则

依赖倒置原则的原始定义是：High level modules should not depend upon low level modules.Bothshould depend upon abstractions.Abstractions should not depend upondetails.Details should depend upon abstractions.

翻译过来，包含三层含义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。更精简的解释就是面向接口编程。

采用依赖倒置原则（DIP）可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

我们可以通过例子来了解依赖倒置：



### 接口隔离原则

### 迪米特法则

### 开闭原则

## 二、设计模式

