# Java虚拟机篇二虚拟机执行子系统

**禁止转载！！**

> 本篇是Java虚拟机的学习笔记的第二篇，虚拟机执行子系统。
>
> 参考资料：深入理解Java虚拟机周志明第三版以及互联网资源具体引用会在文中标注
>
> 我在学习的过程中感觉类的文件结构和类加载机制以及虚拟机字节码执行引擎只需要大概了解，对整体结构和整体流程了解即可，这两部分更像是字典，当我们需要时再翻阅资料详细的了解其具体的细节。
>
> 因此本文大部分都是从《深入理解Java虚拟机周志明第三版》进行拷贝和引用的，目的是为了学习一遍并加深印象，同时整理重要知识点方便日后进行复习。

# 一、类的文件结构

## 1.1 概述

我们编写的程序需要被编译成由0和1组成的二进制格式才能被计算机执行。但由于近十年内虚拟机及大量建立在虚拟机上的程序语言蓬勃发展，把程序编译成二进制本地机器码已不再是唯一的选择。Oracle公司以及其他虚拟机发行商发布过许多可以运行在各种不同硬件平台和操作系统上的Java 虚拟机，这些虚拟机都可以载人和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。

实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java 虚拟机不与包括 Java 语言在内的任何程序语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联Class 文件中包含了 Java 虚拟机指令集、符号表以及若干其他辅助信息。基于安全方面的考虑，《 Java 虚拟机规范》中要求在 Class 文件必须应用许多强制性的语法和结构化约束，但图灵完备的字节码格式，保证了任意一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。作为一个通用的、与机器无关的执行平台，任何其他语言的实现者都可以将 Java 虚拟机作为他们语言的运行基础，以 Class 文件作为他们产品的交付媒介。

实际上，虚拟机不关心你到底使的是什么语言，他与程序语言的关系如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230419135205520](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419135205520.png)

## 1.2 Class类文件结构

> 文件格式、结构的学习实际上类似于读字典，虽然枯燥但是无可避免，如果想深入学习虚拟机相关知识，这是无法回避的。
>
> [winhex下载地址](http://www.x-ways.net/winhex.zip)winhex 是一个专门用来对付各种日常紧急情况的工具。它可以用来检查和修复各种文件、恢复删除文件、硬盘损坏造成的数据丢失等。同时它还可以让你看到其他程序隐藏起来的文件和数据。总体来说是一款非常不错的 16 进制编辑器。在本节中用于查看class文件的字节码。

Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在文件中，中间没有任何分隔符，这使得整个CLASS文件存储的内容全部是程序运行的必要数据。当遇到需要占用8个字节以上的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。

> 高位在前的方式被称为Big-Endian，具体顺序是指按照高位字节在地址最低位，最低字节在地址最高位来存储数据，是SPARC等处理器的默认多字节存储顺序。x86等处理器是使用了相反的Little-Endian。

根据《Java 虚拟机规范》的规定，Class 文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型:`无符号数`和`表`。

- 无符号数属于基本的数据类型，以u1、u2、u4、u8 来分别代表 1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8 编码构成字符串值。
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分所有表的命名都习惯性地以`info`结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上也可以视作是一张表，这张表由下图（图片来自《深入理解Java虚拟机周志明第三版》）展示的数据项按严格顺序排列构成。

![image-20230419140056789](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419140056789.png)

无论是无符号数还是表，当描述同一类型但数量不定的多个数据时，经常使用一个前置的容量计数器加若干个数据项的形式，这一系列连续的数据被称为集合。

> 上图中的数据项无论是顺序还是数量，甚至于数据存储的字节序(Byte Ordering，Class 文件中字节序为Big-Endian)这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变。

### 1.2.1 魔数与Class文件的版本

每个Class文件的前四个字节被称为魔数，他的唯一作用就是确定这个文件是否是一个能被虚拟机接受的Class文件。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。Class 文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE (咖啡宝贝)。

> 很多文件格式标准中都有使用魔数来进行身份识别的习惯，警如图片格式，如 GIF 或者JPEG 等在文件头中都存有魔数。

紧接着魔数的4个字节存储的是 Class 文件的版本号：第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。Java 的版本号是从45 开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加 1(JDK 1.0-1.1使用了45.0-45.3 的版本号)，高版本的JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，因为《Java 虚拟机规范》在Class 文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的 Class 文件。

我们搞一个简单的class文件：

```java
public class SimpleClass {
    private int m;

    public int inc() {
        return m + 1;
    }
}
```

我们将上面的代码编译成class文件，然后用WinHex打开，如下图：

![image-20230419141447906](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419141447906.png)

从上图可见，class文件的开头四个字节时0xCAFEBABE，后四个字节是次版本号是0x0000，主版本号是0x0034转换成十进制就是52，也就是说可以被JDK8及以上的虚拟机执行。JDK的版本号对应如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230419142541315](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419142541315.png)

次版本号在JDK1.2以后均未被使用，全部固定为0.

### 1.2.2 常量池

紧接着主、次版本号之后的是常量池入口，常量池可以比喻为 Class 文件里的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据，通常也是占用 Class 文件空间最大的数据项目之一，另外，它还是在 Class 文件中第一个出现的表类型数据项目。

由于常量数量不固定，所以常量池入口放了一个u2类型的数据，代表常量池容量计数器，与Java 中语言习惯不同，这个容量计数是从1而不是0开始的，如下图所示，常量池容量（偏移地址0x0000008）为十六进制数 0x0016，即十进制的 22，这就代表常量池中有 21项常量，索引值范围为1~21。

![image-20230419143200670](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419143200670.png)

设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达*不引用任何一个常量池*项目的含义，可以把索引值设置为0来表示。Class 文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，都是从0开始。

常量池中主要存放两大类常量：`字面量 (Literal)` 和`符号引用(Symbolic References)`。字面量比较接近于 Java 语言层面的常量概念，如文本字符串、被声明为 final的常量值等；而符号引用则属于编译原理方面的概念，主要包括下面几类常量：

- 被模块导出或开放的包（package）
- 类和接口的全限定名（(Fully Qualified Name）
- 字段的名称和描述符（(Descriptor）
- 方法的名称和描述符
- 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
- 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-ComputedConstant）

Java代码编译时，没有C中的连接步骤，而是虚拟机加载Class文件时动态连接，也就是说Class文件中不会保存各个方法、字段最终在内存的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就是说无法直接被虚拟机使用。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

常量池的每一项都是一个表，截至JDK13共有17种常量，这些表结构的第一位是一个u1类型的标志为，代表当前常量属于哪种常量类型。17种常量如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230419144122378](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419144122378.png)

![image-20230419144606930](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419144606930.png)

之所以常量池是最繁琐的数据，是因为这17种常量类型各自有完全独立的数据结构，之间也没有共性和联系。

我们这里举两个例子（来自《深入理解Java虚拟机周志明第三版》）：

![image-20230419145600334](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419145600334.png)

上图中tag 是标志位，它用于区分常量类型；name index 是常量池的索引值，它指向常量池中个`CONSTANT_Utf8_info` 类型常量，此常量代表了这个类(或者接口)的全限定名。

![image-20230419145611533](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419145611533.png)

length 值说明了这个UTF-8 编码的字符串长度是多少字节，它后面紧跟着的长度为length 字节的连续数据是一个使用 UTF-8 缩略编码表示的字符串。

> UTF-8缩略编码与UTF-8编码的区别是：从`\u0001`到`\u007f`之间的字符（相当于1-127的ASCII码）的缩略编码用一个字节，从`\u0080`到`\u07ff`之间的所有字符用两个字节，从`\u0800`到`\uffff`之间的所有字符与普通UTF-8一致用三个字节表示。

> 注意：由于Class 文件中方法、字段等都需要引用`CONSTANT_Utf8_info`型常量来描述名称，所以这个常量的最大长度也就是 Java 中方法、字段名的最大长度。而这里的最大长度就是 length 的最大值，既u2 类型能表达的最大值 65535，所以 Java 程序中如果定义了超过 64KB 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。

上面举了两个例子，但实际上JDK提供了用于分析Class文件字节码的工具：`javap`。

> javap参数：-verbose 输出栈大小，方法参数的个数

我们使用javap分析上面的SimpleClass.class字节码文件，如下图：

![image-20230419150614400](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419150614400.png)

我们可以看到，21个常量已经计算出来了。

> 关于17种常量类型结构详见4.1小节

### 1.2.3 访问标志

常量池结束之后，紧接着的2个字节表示访问标志（`access_flags`），这个标志用于识别一些类或者接口层次的访问信息，包括：

- 这个Class是类还是接口
- 是否是public类型
- 是否是abstract类型
- 是否被声明为final
- ......

具体含义如下图（来自《深入理解Java虚拟机周志明第三版》）

![image-20230419151252625](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419151252625.png)

访问标志目前截至JDK9只定义了9个，没有用到的一律为0。我们上面的SimpleClass.class中只用了public修饰了，且不是final的，所以最终访问标志是`0x0021` 由 `0x0020 | 0x0001`计算得来。

### 1.2.4 类索引、父类索引与接口索引集合

类索引（`this_class`）、父类索引(`super_class`)都是一个u2类型的数据，而接口索引集合（`interfaces`）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了`java.lang.Object` 之外，所有的Java 类都有父类，因此除了 `java.lang.Object` 外，所有 Java 类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 关键字(如果这个 Class 文件表示的是一个接口，则应当是 extends 关键字)后的接口顺序从左到右排列在接口索引集合中。

类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为`CONSTANT_Class_info` 的类描述符常量，通过 `CONSTANT_Class_info` 类型的常量中的索引值可以找到定义在 `CONSTANT_Utf8_info`类型的常量中的全限定名字符串。接口索引集合的入口第一项u2类型的数据为接口计数器，表示索引表的容量，如果没有实现接口则为0。类索引查找全限定名的过程如下图：

![image-20230419154125972](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419154125972.png)

从javap中也能找到类和父类的常量，如下图：

![image-20230419154527414](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419154527414.png)

### 1.2.5 字段表集合

字段表（`field_info`）用于描述接口或类中声明的变量。Java中的字段（Field）包括类级变量和实例级变量，但不包括方法内部的局部变量。在Java中，字段可以包括的修饰符有字段的作用域(public、private、protected 修饰符)、是实例变量还是类变量 (static 修饰符)、可变性 (final)并发可见性 (volatile 修饰符，是否强制从主内存读写)、可否被序列化(transient 修饰符)字段数据类型(基本类型、对象、数组)、字段名称。这些信息都是引用常量池中的常量来描述，字段表最终格式如下图：

![image-20230419154853630](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419154853630.png)

字段修饰符在`access_flags`项目中，它与类中的`access_flags`是非常相似的，都是一个u2的数据类型，其可以设置的标志位如下图：

![image-20230419161610525](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419161610525.png)

跟随`access_flags`标志的是两项索引值：`name_index`和`descriptor_index`。他们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。

> 以SimpleClass类为例：
>
> - 全限定名：`com/learn/jvmtest/SimpleClass`
> - 字段方法的简单名称：inc、m

方法和字段的描述符规则如下图：

![image-20230419162051173](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419162051173.png)

对于数组类型，每一维将使用前置的`[`来描述，比如String类型的二维数组被记录为`[[Ljava/lang/String`,整形数组被记为`[I`。

描述方法时，按照先参数列表、后返回值的顺序描述，比如方法`void inc()`描述符为`()V`；方法`java.lang.toString()`描述符为`()Ljava/lang/String`；方法`int indexOf(cahr[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex)`描述符为`([CII[CIII)I`。

字段表包含的固定数据到`descriptor_index`就结束了，上图中还有两个时一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中符假描述0-n项的额外信息。关于属性表详见1.2.7小节。

> 字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本 Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。另外，在 Java 语言中字段是无法重载的，两个字段的数据类型修饰符不管是否相同，都必须使用不一样的名称，但是对于 Class 文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的。

### 1.2.6 方法表集合

如果理解了字段表，那么方法表的描述与字段表采用了几乎一致的方式，方法表结构如下：

![image-20230419163143578](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419163143578.png)

方法表的访问标志`access_flags`取值如下：

![image-20230419163219580](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419163219580.png)

方法的定义可以通过访问标志、名称索引、描述符索引描述清楚，那么方法里的代码怎么办？实际上经过javac编译成字节码指令后，存放在方法属性表集合的一个名为Code的属性里面了。

> 与字段表集合相对应地，如果父类方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器`<clinit>()`方法和实例构造器`<init>()`方法。
>
> 在 Java 语言中，要重载 (Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以 Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在 Class 文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中的。

### 1.2.7 属性表集合

属性表在前面已经见过多次，Class文件、字段表、方法表都可以有自己的属性表集合，以描述一些场景专有的信息。与Class文件中其他的数据项目要求严格的顺序、长度、内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java 虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。

> 为了能正确解析 Class 文件，《 Java 虚拟机规范》最初只预定义了9 项所有 Java 虚拟机实现都应当能识别的属性，而在最新的《 Java 虚拟机规范》的 Java SE 12 版本中，预定义属性已经增加到 29 项，关于虚拟机规范预定义的属性，详见4.2小节。

对于每一个属性，它的名称都需从常量池中引用一个`CONSTANT_Utf8_info`类型的常量来进行表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性说明属性值所占用的位数即可。一个符合规则的属性表应该满足如下定义的结构。

![image-20230419164229581](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419164229581.png)

## 1.3 字节码指令简介

Java虚拟机的指令（JVM指令）由一个字节长度的、代表某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零到多个代表操作所需要的参数（称为操作数，Operand）构成。由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。

JVM的指令集是基于栈而不是寄存器，也就是说不会直接操作本地变量表。基于栈可以具备很好的跨平台性（因为寄存器指令集往往和硬件挂钩），但缺点在于，要完成同样的操作，基于栈的实现需要更多指令才能完成（因为栈只是一个FILO结构，需要频繁压栈出栈）。另外，由于栈是在内存实现的，而寄存器是在CPU的高速缓存区，相较而言，基于栈的速度要慢很多，这也是为了跨平台性而做出的牺牲。

字节码指令集可以算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了Java虚拟机操作码长度为一个字节（即0-255），所以指令集的操作码数不能超过256条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构，比如将一个16位长度的无符号整数使用两个无符号字节存起来（假设命名为byte1和byte2），那他们的值应该是：`(byte1 <<8 | byte2)`。这种操作在某种程度上会导致解释字节码时损失一些性能，但这样做优势也十分明显，那就是放弃了操作数长度对齐就意味着可以省略大量的填充和间隔符号；用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。这种尽可能追求数据量小、高效率传输是由Java设计之初的技术背景决定的。

如果不考虑异常处理的话，那JVM虚拟机的解释器可以用下面这段伪代码作为最基本的执行模型来理解，这个执行模型虽然简单，但依然可以正确有效的工作。

~~~ 
do {
	自动计算PC寄存器的值加1；
	根据PC寄存器指示的位置，从字节码流中取出操作码；
	if(字节码存在操作数) 从字节码流中取出操作数；
	执行操作码定义的操作；
} while(字节码流长度 > 0)
~~~

### 1.3.1 字节码与数据类型

在JVM的指令集中，大多数指令都包含其操作所对应的数据类型信息，比如iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的就是float类型的数据。这两条指令可能在JVM内部由同一段代码实现，但是在Class文件中它们必须拥有各自独立的操作码。

对于大部分与数据类型有关字节码指令，他们的操作码助记符中都有特殊的字符来表示专门为哪种数据类型服务，比如i对应int类型，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。因为JVM的操作码只有一字节，所以包含了数据类型的操作码为指令集的设计带来很大的压力，所以Java虚拟机的指令集对于特定的操作只提供了有限的相关指令去支持。下图列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用特殊含义的字符去替换opcode一列中的T就可以得到具体的字节码指令。如果为空说明虚拟机不支持这种数据类型执行这种操作（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230419213637522](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419213637522.png)

![image-20230419213651657](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419213651657.png)

上图中大部分指令都不支持byte、char、short甚至基本都不支持boolean。编译器会在编译期或运行期将 byte和short类型的数据带符号扩展(Sign-Extend)为相应的int类型数据，将 boolean和 char类型数据零位扩展(Zero-Extend)为相应的int类型数据。与之类似，在处理 boolean、byte、short 和 char类型的数组时，也会转换为使用对应的 int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和 char 类型数据的操作，实际上都是使用相应的对int类型作为运算
类型(ComputationalType)来进行的。

### 1.3.2 加载和存储指令

加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括：

- 将一个局部变量加载到操作栈：`iload,iload_<n>,lload,lload_<n>,fload,fload_<n>,dload,dload_<n>,aload,aload_<n>`
- 将一个数值从操作数栈存储到局部变量表：`istore,istore_<n>,lstore,lstore_<n>,fstore,fstore_<n>,dstore,dstore_<n>,astore,astore_<n>`
- 将一个常量加载到操作数栈：`bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_m1,iconst_<i>,lconst_<l>,fconst_<f>,dconst_<d>`
- 扩充局部变量表的访问索引的指令：`wide`

存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令比如访问对象的字段或数组元素的指令也会向操作数栈传输数据。

上面的指令助记符中，有一部分是以尖括号结尾的，这些指令助记符实际代表了一组指令，比如`iload_<n>`代表了`iload_0,iload_1,iload_2,iload_3`这几条指令。这几组指令都是某个带有一个操作数的通用指令`ilaod`的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作.因为实际上操作数就隐含在指令中。除了这点不同以外，它们的语义与原生的通用指令是完全一致的 ，例如` iload_0`的语义与操作数为0时的 `iload`指令语义完全一致。

### 1.3.3 运算指令

算术指令用于对操作数栈上的两个值进行某种特定运算，并把结果重新存入到操作栈顶。大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现。无论是哪种算术指令，均是使用 Java 虚拟机的算术类型来进行计算的，换句话说是不存在直接支持 byte、short、char 和 boolean 类型的算术指令，对于上述几种数据的运算，应使用操作int 类型的指令代替。所有的算术指令包括：

- 加法指令:`iadd,ladd,fadd,dadd`
- 减法指令:`isub,lsub,fsub,dsub`
- 乘法指令:`imul,lmul,fmul,dmul`
- 除法指令:`idiv,ldiv,fdiv,ddiv`
- 求余指令:`irem,lrem,frem,drem`
- 取反指令:`ineg,lneg,fneg,dneg`
- 位移指令:`ishl,ishr,iushr,lshl,lshr,lushr`
- 按位或指令:`ior,lor`
- 按位与指令:`iand,land`
- 按位异或指令:`ixor,lxor`
- 局部变量自增指令:`iinc`
- 比较指令:`dcmpg,dcmpl,fcmpg,fcmpl,lcmp`

Java 虚拟机的指令集直接支持了在《 Java 语言规范》中描述的各种对整数及浮点数操作(详情参见《 Java 语言规范》4.2.2 节和 4.2.4 节)的语义。数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现象,对于程序员来说是很容易理解的，但其实《Java 虚拟机规范》中并没有明确定义过整型数据溢出具体会得到什么计算结果，仅规定了在处理整型数据时，只有除法指令 (idiv 和 ldiv)以及求余指令(irem和lrem)中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，其余任何整型数运算场景都不应该抛出运行时异常。

> 《Java 虚拟机规范》要求虚拟机实现在处理浮点数时，必须严格遵循IEEE 754 规范中所规定行为和限制，也就是说Java 虚拟机必须完全支持 IEEE 754 中定义的“非正规浮点数值”(Denormalized Floating-Point Number)和“逐级下溢”(GradualUnderflow)的运算规则。这些规则将会使某些数值算法处理起来变得明确，不会出现模棱两可的困境。譬如以上规则要求 Java 虚拟机在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值；如果有两种可表示的形式与该值一样接近，那将优先选择最低有效位为零的。这种舍入模式也是IEEE 754 规范中的默认舍入模式，称为向最接近数舍入模式。而在把浮点数转换为整数时，Java 虚拟机使用IEEE 754标准中的向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近，但是不大于原值的数字来作为最精确的舍入结果。
>
> 另外，Java 虚拟机在处理浮点数运算时，不会抛出任何运行时异常 (这里所讲的是Java语言中的异常，请读者勿与IEEE 754规范中的浮点异常互相混淆，IEEE 754 的浮点异常是一种运算信号)，当一个操作产生溢出时，将会使用有符号的无穷大来表示;如果某个操作结果没有明确的数学定义的话，将会使用 NaN(Not a Number)值来表示。所有使用NaN 值作为操作数的算术操作，结果都会返回 NaN。
>
> 在对 long类型数值进行比较时，Java 虚拟机采用带符号的比较方式，而对浮点数值进行比较时(dcmpg、dcmpl、fcmpg、fcmpl)，虚拟机会采用IEEE 754 规范所定义的无信号比较(Nonsignaling Comparison)方式进行。

### 1.3.4 类型转换指令

类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。

Java 虚拟机直接支持(即转换时无须显式的转换指令) 以下数值类型的宽化类型转换(Widening Numeric Conversion，即小范围类型向大范围类型的安全转换):

- int类型到long、float、double类型
- long类型到float、double类型
- float类型到double类型

与之相对的，处理摘窄化类型转换(Narrowing Numeric Conversion)时，就必须显示的使用转化指令来完成这些转换指令包括`i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f`。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。

在将 int 或 long类型窄化转换为整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的内容，N 是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。对于了解计算机数值存储和表示的程序员来说这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低 N 字节的首位了。

Java 虚拟机将一个浮点值窄化转换为整数类型 T(T 限于 int 或long 类型之一)的时候必须遵循以下转换规则:

- 如果浮点值是 NaN，那转换结果就是 int或 long 类型的0。
- 如果浮点值不是无穷大的话，浮点值使用 IEEE 754 的向零舍人模式取整，获得整数值v。如果v在目标类型T(int或long)的表示范围之类，那转换结果就是v；否则将根据v的符号，转换为 T 所能表示的最大或者最小正数。

从double类型到float类型做窄化转换的过程与IEEE 754 中定义的一致，通过IEEE 754向最接近数舍入模式舍入得到一个可以使用 float 类型表示的数字。如果转换结果的绝对值太小、无法使用 float 来表示的话，将返回 float 类型的正负零；如果转换结果的绝对值太大、无法使用 float 来表示的话，将返回 float 类型的正负无穷大。对于 double 类型的NaN 值将按规定转换为 float 类型的 NaN值。

尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是《Java虚拟机规范》中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。

### 1.3.5 对象的创建与访问指令

虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令(数组和普通类的类型创建过程是不同的)。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：

- 创建类实例的指令：`new`
- 创建数组的指令：`newarray,anewarray,multianewarray`
- 访问类字段（static字段，即类变量）和实例字段（非static字段）的指令：`getfield,putfield,getstatic,putstatic`
- 把一个数组元素加载到操作数栈的指令：`baload,caload,saload,iaload,laload,faload,daload,aaload`
- 将一个操作数栈的值存储到数组元素中的指令：`bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore`
- 取数组长度的指令：`arraylength`
- 检查类实例类型的指令：`instanceof,checkast`

### 1.3.6 操作数栈管理指令

如同操作普通数据结构一样，Java虚拟机提供了一些直接用于操作操作数栈的指令：

- 将操作数栈的栈顶一个或两个元素出栈：`pop,pop2`
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：`dup,dup2,dup_x1,dup2_x1,dup_x2,dup2_x2`
- 将栈最顶端的两个数值互换：`swap`

### 1.3.7 控制转移指令

控制转移指令可以让 Java 虚拟机有条件或无条件地从指定位置指令 (而不是控制转移指令)的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改 PC 寄存器的值。控制转移指令包括：

- 条件分支：`ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonull,if_icmpeq.if_icmpne,if_icmplt,uf_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne`
- 复合条件分支：`tableswitch,lookupswitch`
- 无条件分支：`goto,goto_w,jsr,jsr_w,ret`

在 Java 虚拟机中有专门的指令集用来处理 int 和reference 类型的条件分支比较操作，为了可以无须明显标识一个数据的值是否 null，也有专门的指令用来检测 nul值。

与前面算术运算的规则一致，对于 boolean 类型、byte 类型、char类型和 short类型的条件分支比较操作，都使用 int 类型的比较指令来完成，而对于 long 类型、flat类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令 (dcmpg、dcmpl、fcmpg、fcmpl、lcmp)，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。由于各种类型的比较最终都会转化为int 类型的比较操作，int类型比较是否方便、完善就显得尤为重要，而 Java 虚拟机提供的int 类型的条件分支指令是最为丰富、强大的。

### 1.3.8 方法调用和返回指令

方法调用这里列举五条指令用于方法调用：

- invokevirtual：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言最常见得分派方式。
- invokeinterface：用于调用接口方法，他会在运行时搜索一个实现了这个接口方法得对象，找到适合的方法进行调用。
- invokespecial：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
- invokestatic：用于调用类静态方法。
- invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面四条调用指令的分派逻辑都固化在 Java 虚拟机内部，用户无法改变，而invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。

方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn (当返回值是 boolean、byte、char、short 和int 类型时使用)lreturn、freturn、dreturn和areturn，另外还有一条return 指令供声明为 void 的方法、实例初始化方法、类和接口的类初始化方法使用。

### 1.3.9 异常处理指令

在Java程序中显式抛出异常的操作 (throw 语句)都由athrow 指令来实现，除了用throw 语句显式抛出异常的情况之外，《 Java 虚拟机规范》还规定了许多运行时异常会在其他Java 虚拟机指令检测到异常状况时自动抛出。例如整数运算中，当除数为零时，虚拟机会在idiv或ldiv 指令中抛出ArithmeticException 异常。

而在 Java 虚拟机中，处理异常 (catch 语句)不是由字节码指令来实现的 (很久之前曾经使用jsr 和 ret 指今来实现，现在已经不用了)，而是采用异常表来完成。

### 1.3.10 同步指令

Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程(Monitor，更常见的是直接将它称为“锁”)来实现的。

方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程然后才能执行方法，最后当方法完成(无论是正常完成还是非正常完成)时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。

同步一段指令集序列通常是由 Java 语言中的 synchronized语句块来表示的，Java 虚拟机的指令集中有 `monitorenter`和 `monitorexit` 两条指令来支持synchronized 关键字的语义，正确实现synchronized关键字需要 Javac 编译器与Java 虚拟机两者共同协作支持。

我们举个例子，先搞个同步方法：

```java
public void onlyMe(Foo f){
    synchronized (f){
        doSomething();
    }
}
```

然后javap查看其字节码指令：

![image-20230420115649644](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230420115649644.png)

编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须有其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。

从上面的字节码序列中可以看到，为了保证在方法异常完成时 monitorenter 和monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。

## 1.4 公有设计与私有实现

Java虚拟机规范描绘了JVM应该有共同程序存储格式：Class文件格式以及字节码指令集。这些内容与硬件、操作系统和具体的Java虚拟机实现之间是完全独立的，虚拟机实现可能更可以看作是各类Java平台实现互相安全交互的手段。

理解公有设计与私有实现的界限是非常有必要的，任何一款Java虚拟机实现都必须能读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。拿着Java虚拟机规范实现固然可行，但是一个优秀的虚拟机实现还应该在约束下做出修改和优化，并且规范鼓励开发者这样做。只要优化后的Class文件可以被正确的读取，并且保证语义完整。虚拟机如何实现完全是实现者的事情，只要他在外部接口上看起来与规范一致即可。

虚拟机实现主要有两种方式：

- 将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集
- 将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即时编译器代码生成技术）

精确定义虚拟机的行为和目标文件格式，不应该对虚拟机的实现产生太多限制。



# 二、虚拟机类加载机制

## 2.1 概述

上一章节学习了Class文件存储格式的具体细节，在Class文件的各类信息最终都需要加载到虚拟机中才能被运行和使用。

Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作**虚拟机的类加载机制**。与那些在编译时需要进行连接的语言不同，在Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过 Java 预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。这种动态组装应用的方式目前已广泛应用于 Java 程序之中，从最基础的 Applet、JSP 到相对复杂的OSGi技术，都依赖着 Java语言运行期类加载才得以诞生。

## 2.2 类加载的时机

一个类或接口从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析三个阶段统称为连接，整体流程如下（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230420131523057](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230420131523057.png)

上图中，加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，类或接口的加载过程必须按照这种顺序按部就班的开始，但是解析阶段可以在初始化阶段之后在开始，这是为了支持Java语言的运行时绑定的特性。

关于在什么情况下需要开始类加载过程的第一个阶段“加载”,《 Java 虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段《Java 虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”(而加载验证、准备自然需要在此之前开始)：

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类或接口没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java场景如下：

   - 使用new关键字实例化对象时

   - 读取或设置一个静态字段（被final修饰，在编译期放入常量池的静态字段除外）的时候

     > 通过子类调用父类静态字段，只会触发父类的初始化，不会触发子类的初始化。

   - 调用一个类或接口的静态方法的时候

2. 使用`java.lang.reflect`包的方法对类或接口进行反射调用的时候，如果类或接口没有进行过初始化，则需要先触发初始化。

3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

   > 但是接口初始化时并不要求父接口也全部完成初始化，只有真正用到了才会初始化。

4. 当虚拟机启动的时候，用户需要指定一个要执行的主类（主类就是包含main方法的类），虚拟机会先初始化这个主类。

5. 当使用JDK7新加入的动态语言支持的时候，如果一个`java.lang.invoke.MethodHandle`实例最后解析结果为`REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial`四种类型的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。

6. 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生初始化，则接口要在其之前被初始化。

对于这六种会触发类型进行初始化的场景，《 Java 虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。

## 2.3 类加载的过程

### 2.3.1 加载

在加载阶段，Java虚拟机需要完成三件事情

1. 通过一个类的全限定名来获取定义此类的二进制流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表着这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口

《Java 虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与 Java 应用的灵活度都是相当大的。例如“通过一个类的全限定名来获取定义此类的二进制字节流这条规则，它并没有指明二进制字节流必须得从某个 Class 文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。仅仅这一点空隙，Java 虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台，Java 发展历程中，充满创造力的开发人员则在这个舞台上玩出了各种花样，许多举足轻重的 Java 技术都建立在这一基础之上，比如：

- 从ZIP压缩包获取，后续发展成了JAR、EAR、WAR
- 从网络中获取，最典型的就是Web Applet
- 运行时计算生成，这种场景最多的就是动态代理技术，在`java.lang.reflect.Proxy`中，就是使用了`ProxyGenerator.generateProxyClass`来为特定接口生成形式为`*$Proxy`的代理类的二进制字节流。
- 由其他文件生成，典型的就是JSP，由JSP文件生成Class文件
- 从数据库获取，这种场景相对少见些，例如有些中间件服务器(如SAPNetweaver)可以选择把程序安装到数据库中来完成程序代码在集群间的分发
- 从加密文件获取，这时典型的防止Class文件被反编译的保护措施
- ......

加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式(重写一个类加载器的findClass0或loadClass0 方法)，实现根据自己的想法来赋予应用程序获取运行代码的动态性。

加载阶段结束后，Java 虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《 Java 虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在 Java 堆内存中实例化一个java.lang.Class 类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。

加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。

### 2.3.2 验证

验证是连接的第一步，这一阶段目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范的全部约束要求》，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

Java 语言本身是相对安全的编程语言，但Class 文件并不一定只能由 Java 源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中出 Class 文件在内的任何途径产生。上述 Java代码无法做到的事情在字节码层面上都是可以实现的，至少语义上是可以表达出来的。Java虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是 Java 虚拟机保护自身安全的重要措施。

验证阶段是非常重要的，这个阶段是否严谨，直接决定了 Java 虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。直到2011年《 Java 虚拟机规范(Java SE7版)》出版，规范中大幅增加了验证过程的描述(篇幅从不到 10 页增加到 130 页)这时验证阶段的约束和验证规则才变得具体起来。验证阶段规则有很多，但从整体上看，验证阶段大致上会完成下面四个阶段的检验动作:文件格式验证、元数据验证、字节码验证和符号引用验证。

**文件格式验证**

验证字节流是否符合Class文件格式的规范，并且能被当前虚拟机处理，可能包括的验证点如下：

- 是否以魔数开头
- 主次版本是否在虚拟机接受范围内
- 常量池的常量中是否有不被支持的常量类型(检查常量 tag 标志)
- ......

该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java 类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入 Java 虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。

**元数据验证**

第二阶段是对字节码描述的信息进行语义分析，以保证符合《Java虚拟机规范的要求》，可能包括的验证点如下：

- 这个类是否有父类
- 这个类的父类是否继承了不允许被继承的类（final修饰）
- 如果不是抽象类，则是否实现了父类和接口的要求实现所有方法
- ......

这阶段验证主要目的是对类的元数据信息进行语义校验，保证不与《Java虚拟机规范的要求》定义的元数据信息相悖。

**字节码验证**

第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体(Class 文件中的 Cde 属性)进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如:

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int 类型的数据，使用时却按 long 类型来加载入本地变量表中”这样的情况。
- 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
- ......

如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。即使字节码验证阶段中进行了再大量、再严密的检查，也依然不能保证这一点。

> 这里涉及了离散数学中一个很著名的问题--“停机问题”(Halting Problem)，即不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。在我们讨论字节码校验的上下文语境里，通俗一点的解释是通过程序去校验程序逻辑是无法做到绝对准确的，不可能用程序来准确判定一段程序是否存在 Bug。

田于数据流分析和控制流分析的高度复杂性，Java 虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，在JDK 6之后的Javac 编译器和Java 虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到 Javac 编译器里进行。具体做法是给方法体 Code 属性的属性表中新增加了一项名为“StackMapTable”的新属性，这个属性描述了方法体所有的基本块 (Basic Block，指按照控制流拆分的代码块) 开始时本地变量表和操作栈应有的状态，在字节码验证期间，Java 虚拟机就不需要根据程序推导这些状态的合法性，只需要检查 StackMapTable 属性中的记录是否合法即可。

> JDK 6的HotSpot 虚拟机中提供了`-XX:-UseSplitVerifier` 选项来关闭掉这项优化，或者使用参数`-XX:+FailverToOldVerifier` 要求在类型校验失败的时候退回到旧的类型推导方式进行校验。而到了JDK 7之后，尽管虚拟机中仍然保留着类型推导验证器的代码，但是对于主版本号大于 50 (对应JDK 6)的 Cass 文件，使用型查来完成数据流分析校验则是唯一的选择，不允许再退回到原来的类型推导的校验方式。

**符号引用验证**

最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用@的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验下列内容：

- 符号引用中通过字符串描述的全限定类名是否能找到对应的类
- 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
- 符号引用中的类、字段、方法的可访问性 (private、protected、public、package)是否可被当前类访问
- ......

符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证Java 虚拟机将会抛出一个`java.lang.IncompatibleClassChangeError`的子类异常，典型的如:`java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError` 等

验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。

> 如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

### 2.3.3 准备

准备阶段是正式为类中定义的变量（静态变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应该在方法区进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 7及之前，HtSpot 使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8 及之后，类变量则会随着 CIass对象一起存放在 Java 堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。

关于准备阶段，还有两个容易产生混淆的概念：首先是这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值。比如`public static int value =123`。在准备阶段过后初始值是0而不是123，因为这时未执行Java方法，把value赋值为123的putstatic指令是程序被编译后，存在于类构造器`<clinit>()`方法值重，所以赋值123的动作要到初始化阶段才会被执行。

有通常就肯定有特殊情况，如果类字段的字段属性表存在ConstantValue属性，那么准备阶段就会被初始化为ConstantValue属性指定的初始值，比如`public static final int value =123`，那么准备阶段就会根据ConstantValue的设置将value赋值123。

### 2.3.4 解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，在Class文件中以`CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info`等类型的常量出现。

- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容，各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。
- 直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

《Java虚拟机规范》中并未规定解析阶段发生的具体时间，只是要求在执行`anewarray、checkcast、getfield、getstatic、 instanceof、invokedynamic 、invokeinterface 、 invokespecial、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、 new、putfield、putstatic`这17个用于操作符号引用的字节码之前，先对符号引用进行解析。是类被加载时先解析还是使用前去解析由虚拟机实现自行判断。

对同一个符号引用进行多次解析请求是很常见的事情，除 invokedynamic 指令以外，虚拟机实现可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，Java 虚拟机都需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功;同样地，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进 Java虚拟机内存之中。

当然了invokedynamic 例外，当碰到某个前面已经由invokedynamic 指令触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生效。因为invokedynamic 指令的目的本来就是用于动态语言支持，它对应的引用称为*动态调用点限定符(Dynamically-Computed Call Site Specifier)*这里“动态”的含义是指必须等到程序实际运行到这条指令时，解析动作才能进行。、

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池的`CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dynamic_info、CONSTANT_InvokeDynamic_info` 8种常量类型。

这里先学习前四种，后面的在动态语言时在学习。

**类或接口的解析**

假设当前代码所处的类为 D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：

1. 如果 C不是一个数组类型，那虚拟机将会把代表的全限定名传递给 D 的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。
2. 如果 C是一个数组类型，并且数组的元素类型为对象，也就是N 的描述符会是类似`[Ljava/lang/Integer`的形式，那将会按照上面第一条的规则加载数组元素类型，接着由虚拟机生成一个代表该数组维度和元素的数组对象。
3. 如果上面两步没有出现任何异常，那么 C 在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D 是否具备对C 的访问权限。如果发现不具备访问权限，将抛出`java.lang.llegalAccessError` 异常。

在模块化被引入了之后，一个public类型也不在意味着程序任何位置都有访问权限，还必须检查模块间的访问权限，比如一个 D拥有C 的访问权限，那就意味着以下3条规则中至少有其中一条成立：

- 被访问类C是 public的，并且与访问类D处于同一个模块。
- 被访问类C是 public 的，不与访问类 D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问。
- 被访问类C不是 public 的，但是它与访问类D处于同一个包中。

也就是说涉及可访问性时，都必须考虑模块间访问权限隔离的约束也就是这三条规则。

**字段解析**

要解析一个未被解析过的字段符号引用，首先将会对字段表内 `class index` 项中索引的`CONSTANT_Class_info` 符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那把这个字段所属的类或接口用 C 表示，《Java 虚拟机规范》要求按照如下步骤对 C 进行后续字段的搜索：

1. 如果 C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
2. 否则，如果在 C 中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则，如果 C不是java.lang.Object 的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4. 否则，查找失败，抛出`java.lang.NoSuchFieldError` 异常。

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出`java.lang.IllegalAccessError` 异常。

以上解析规则能够确保 Java 虚拟机获得字段唯一的解析结果，但在实际情况中，Javac编译器往往会采取比上述规范更加严格一些的约束，譬如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但Javac 编译器就可能直接拒绝其编译为 CIass 文件。

**方法解析**

方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的 `class_index`项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索:

1. 由于 Class 文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现`class_index` 中索引的C是个接口的话，那就直接抛出`java.lang.IncompatibleClassChangeError` 异常。
2. 如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 否则，在类 C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类 C 是一个抽象类，这时候查找结束，抛出`java.lang.AbstractMethodError` 异常。
5. 否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`。

最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出`java.lang.IllegalAccessError` 异常。

**接口方法解析**

接口方法也是需要先解析出接口方法表的 `class_index`项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C 表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：

1. 与类的方法解析相反，如果在接口方法表中发现 class index 中的索引C是个类而不是接口，那么就直接抛出`java.lang.IncompatibleClassChangeError` 异常。
2. 否则，在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在接口 C的父接口中递归查找，直到`java.lang.Object`类(接口方法的查找范围也会包括 Object类中的方法)为止，看是否有简单名称和描述符都与目标相匹配的方法如果有则返回这个方法的直接引用，查找结束。
4. 对于规则 3，由于 Java 的接口允许多重继承，如果 C 的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java 虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的 Javac 编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。
5. 否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError` 异常

在JDK 9之前，Java接口中的所有方法都默认是 public 的，也没有模块化的访问约束，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出`java.langIllegalAccessError` 异常。但在JDK 9 中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现`java.langIllegalAccessError` 异常。

### 2.3.5 初始化

类的初始化阶段是类加载过程中的最后一步，之前的几个类加载动作里，除了在加载阶段用户可以自定类加载器局部参与外，其余全部由Java虚拟机来主导控制，直到初始化阶段，Java虚拟机才开始真正执行类中编写的Java代码，将主导权移交给应用程序。

进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。或者说初始化阶段就是执行类构造器 `<clinit>()`方法的过程。`<clinit>()`并不是程序员在 Java 代码中直接编写的方法，它是 Javac 编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及` <clinit>()`方法执行过程中各种可能会影响程序运行行为的细节，这部分比起其他类加载过程更贴近于开发人员的实际工作。

` <clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块`static{}`中的语句合并产生的，编译器的收集顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，在前面的静态语句块中可以赋值，不能访问，例子如下：

```java
public class Test {
    static {
        i = 0;
        System.out.println(i);//Illegal forward reference 编译器报错非法前向引用
    }
    static int i = 1;
}
```

` <clinit>()`方法与类的构造方法不同，它不需要显示地调用父类构造器，Java虚拟机会保证在子类的` <clinit>()`方法执行前，父类的` <clinit>()`已经执行完毕，因此Java虚拟机中第一个被执行的` <clinit>()`方法的类型一定是Object。

> 类的构造方法就是在虚拟机视角中的实例构造器`<init>()`方法

由于父类的` <clinit>()`方法先执行，也就意味着父类中定义的静态语句块要先于子类的变量赋值操作，举例：

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}
static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
    System.out.println(Sub.B);//结果为2
}
```

` <clinit>()`方法对于类或者接口并不是必须的，如果一个类中没有静态语句块，也没有类变量的赋值操作，那么编译器可以不生成` <clinit>()`方法。在接口中不能使用静态语句块，但仍然有变量初始化赋值操作，因此接口也会有` <clinit>()`方法。但执行接口的` <clinit>()`方法不需要先执行父接口的` <clinit>()`，因为只有当父接口的变量被使用时，父接口才会被初始化。接口的实现类也一样不会执行接口的` <clinit>()`方法。

Java虚拟机还必须保证一个类的` <clinit>()`方法在多线程环境中被正确的加锁同步，如果多个线程同时初始化一个类，那么只有一个线程会执行这个类的` <clinit>()`方法，其他线程都只能阻塞等待，直到活动线程完成` <clinit>()`方法。举个例子：

```java
public class DeadLoopClassTest {
    static class DeadLoopClass {
        static {
            if (true) {
                System.out.println(Thread.currentThread() + "init DeadLoopClass");
                while (true) {
                }
            }
        }
    }

    public static void main(String[] args) {
        Runnable script = () -> {
            System.out.println(Thread.currentThread() + "start");
            DeadLoopClass dlc = new DeadLoopClass();
            System.out.println(Thread.currentThread() + "run over");
        };
        Thread thread1 = new Thread(script);
        Thread thread2 = new Thread(script);
        thread1.start();
        thread2.start();
    }
}
```

运行结果如下：

~~~
Thread[Thread-0,5,main]start
Thread[Thread-1,5,main]start
Thread[Thread-0,5,main]init DeadLoopClass
~~~

其中一个线程阻塞，另一个死循环。

## 2.4 类加载器

Java 虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”(Class Loader)。类加载器最初是为了满足 Java Applet 的需求，后来在类层次划分、OSGi、程序热部署代码加密等领域大放异彩，成为 Java 技术体系中一块重要的基石。

### 2.4.1 类与类加载器

类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

这里的相等包括代表类的 Class 对象的 equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。举个例子：

```java
public class TestClassLoader {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        ClassLoader classLoader = new ClassLoader() {
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try {
                    String filename = name.substring(name.lastIndexOf(".") + 1) + ".class";
                    InputStream inputStream = getClass().getResourceAsStream(filename);
                    if (inputStream == null) {
                        return super.loadClass(name);
                    }
                    byte[] bytes = new byte[inputStream.available()];
                    inputStream.read(bytes);
                    return defineClass(name, bytes, 0, bytes.length);
                }catch (IOException e){
                    throw new ClassNotFoundException(name);
                }
            }
        };

        Class<?> aClass = classLoader.loadClass("com.learn.jvmtest.TestClassLoader");
        Object instance = aClass.newInstance();
        System.out.println(instance.getClass());
        System.out.println(instance instanceof com.learn.jvmtest.TestClassLoader);
    }
}
```

运行结果：

~~~
class com.learn.jvmtest.TestClassLoader
false
~~~

我们可以看最终instanceof的结果是false。这是因为Java虚拟机中同时存在了两个TestClassLoader类，一个是虚拟机的应用程序类加载器加载的，另外一个是我们自定义的类加载器加载的，虽然都是同一个Class文件，但在Java虚拟机中还是两个互相独立的类，所以结果是false。

### 2.4.2 双亲委派模型

在Java虚拟机的角度上看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这是使用C++实现，是虚拟机的一部分；另外一种就是其他所有的类加载器，这些全部是Java语言实现，独立于虚拟机外部，并且全部继承`java.lang.ClassLoader`。

自JDK1.2依赖，Java一直保持着三层类加载器、双亲委派的类加载架构，这套架构在Java模块化（详见2.5）后有了一些变动，但依旧未改变主体结构。下面针对JDK8及以前的Java版本介绍三层类加载器、双亲委派的类加载架构。这时的Java程序绝大多数都是用以下三个系统提供的类加载器进行加载。

- 启动类加载器（Bootstrap Class Loader）：这个类加载器负责加载存放在`<JAVA HOME>\lib` 目录，或者被 `-Xbootlasspath `参数所指定的路径中存放的，而且是 Java 虚拟机能够识别的(按照文件名识别，如 rt,jar、tools.jar，名字不符合的类库即使放在 lib 目录中也不会被加载)类库加载到虚拟机的内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用 null 代替即可。
- 扩展类加载器（Extension Class Loader）：这个类加载器是在类`sun.misc.Launcher$ExtClassLoader`中以Java代码的形式实现的。它负责加载`<JAVA HOME>\lib\ext`目录中，或者被`java.ext.dirs`系统变量指定的路径中的所有的类库。这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后这种扩展机制被模块化的天然扩展能力所取代，由于扩展类加载器是由 Java 代码实现的，开发者可以直接在程序中使用扩展类加载器来加载 Class 文件。
- 应用程序类加载器（Application Class Loader）：这个类加载器由 `sun.misc.Launcher$AppClassLoader` 来实现。由于应用程序类加载器是ClassLoader 类中的 `getSystemClassLoader()`方法的返回值，所以有此场合中也称它为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

JDK9之前的 Java应用都是由这三种类加载器互相配合来完成加载的，如果用户认为有必要，还可以加入自定义的类加载器来进行拓展，典型的如增加除了磁盘位置之外的 Class 文件来源，或者通过类加载器实现类的隔离、重载等功能。这些类加载器之间的协作关系“通常”如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230420171712404](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230420171712404.png)

上图展示的各种类加载器之间的层次关系被称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器以外都应该有自己的父类加载器，不过并不是以继承的关系实现，而是通常使用组合关系来复用父加载器的代码。

**双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自已去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去完成加载。**

使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类`java.lang.Object`，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为`java.lang.Object` 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object类，Java 类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。

用以实现双亲委派的代码全部集中在 `java.lang.ClassLoader` 的 `loadClass()`方法之中：

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        //首先检查请求的类是否已经被加载过了
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
                //如果父类加载器抛出 ClassNotFoundException 说明父类加载器无法完成加载请求
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                //当父类加载器无法加载时，在调用本身的findClass方法进行类加载
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

这段代码的逻辑清晰易懂：先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 `loadClass()`方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出ClassNotFoundException 异常的话，才调用自己的`findClass()`方法尝试进行加载。

### 2.4.3 破坏双亲委派模型

双亲委派机制并不是一个强制性约束的模型，而是Java设计者推荐给开发者的类加载器实现方式，Java世界大部分类加载器都遵循这个模型。但凡事均有例外，在Java模块化出现之前，双亲委派模型主要出现三次较大规模的被破坏的情况。我们简单了解一下：

- 由于双亲委派模型在 JDK 1.2之后才被引人，但是类加载器的概念和抽象类 `java.lang.ClassLoader` 则在 Java 的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java 设计者们引人双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免 `loadClass()` 被子类覆盖的可能性，只能在JDK1.2之后的`java.lang.ClassLoader` 中添加一个新的protected 方法 `findClass()`，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 `loadClass()` 中编写代码。
- 双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题(越基础的类由越上层的加载器进行加载)，基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的 API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，比如JNDI服务，JNDI 现在已经是 Java的标准服务，它的代码由启动类加载器来完成加载(在JDK 1.3 时加人到`rt.jar` 的)，JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的 ClassPath 下的JNDI服务提供者接口 (ScrviceProvider Interface，SPI) 的代码，但是启动类加载器是绝不可能认识、加载这些代码的。所以为了解决这个困境，Java 的设计团队只好引入了一个不太优雅的设计：*线程上下文类加载器*。这个类加载器可以通过Thread 类的 `setContextClassLoader()`方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。JNDI服务使用这个线程上下文类加载器去加载所需的 SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则。Java 中涉及 SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB 和JBI等。为了优雅的实现SPI机制，在JDK 6时，JDK 提供了`java.util.ServiceLoader` 类，以*META-INF/services*中的配置信息，辅以责任链模式，这才算是给 SPI的加载提供了一种相对合理的解决方案。
- 第三次被破坏是由于用户对动态性的追求，比如模块热部署。OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGi中称为Bundle)都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle连同类加载器一起换掉以实现代码的热替换。在 OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:
  - 将以java.* 开头的类，委派给父类加载器加载。
  - 否则，将委派列表名单内的类，委派给父类加载器加载。
  - 否则，将Import列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载
  - 否则，查找当前 Bundle的 ClassPath，使用自己的类加载器加载。
  - 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle类加载器加载。
  - 否则，查找 DynamicImport 列表的 Bundle，委派给对应 Bundle 的类加载器加载。
  - 否则，类查找失败。

上面的简单了解即可，我们下面主要看一下Tomcat是如何破坏双亲委派机制的：

> 这一部分参考了以下博客：
>
> - [Tomcat打破双亲委派](http://element-ui.cn/article/show-14479.aspx?action=onClick)
> - [Tomcat打破双亲委派](https://blog.csdn.net/love_yr/article/details/128707088)

Tomcat为什么要破坏双亲委派模型？作为一个web容器，tomcat需要解决以下几个问题：

- 版本隔离：一个web容器可能需要部署多个应用程序，不同的web程序需要依赖一个三方库的不同版本，所以要求每个应用程序的类库都是独立隔离的。

  如果tomcat使用默认的双亲委派机制，那么无法加载不同版本，因为默认加载器只认全限定类名。

- 版本共享：部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程 席，那么要有10份相同的类库加载讲虚拟机

  此问题双亲委派机制是可以解决的。

- Web容器也有自己依赖的类库，不能与应用程序的类库混淆，两者的类库应该隔离开来。

  同版本隔离，也需要打破双亲委派机制

- jsp热加载，web容器需要支持jsp修改后不用重启

  tomcat实际上给每一个jsp文件都对应唯一的类加载器，当jsp修改了，就把类加载器卸载了，然后重新创建类加载器，重新加载。

在Tomcat目录结构中，有三组目录（`/common/*,/server/*和/shared/*`）可以存放公用Java类库，此外还有第四组Web应用程序自身的目录`/WEB-INF/*`，把java类库放置在这些目录中的含义分别是：

- 放置在common目录中：类库可被Tomcat和所有的Web应用程序共同使用。
- 放置在server目录中：类库可被Tomcat使用，但对所有的Web应用程序都不可见。
- 放置在shared目录中：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。
- 放置在`/webapps/WEB-INF`目录中：类库仅仅可以被此Web应用程序使用，对Tomcat和其他Web应用程序都不可见。

对于程序开发人员来说，一般关注的只是webapp中自定义的类。为了支持这套目录结构，Tomcat的实现机制如下图：

![image-20230421094324521](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230421094324521.png)

从图中的委派关系中可以看出，CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用，而 CatalinaClassLoader 和 SharedClassLoader 自己能加载的类则与对方相互隔离。WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个 WebAppClassLoader 实例之间相互隔离。而 JasperLoader 的加载范围仅仅是这个 JSP 文件所编译出来的那一个 Class，它出现的目的就是为了被丢弃：当服务器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader 的实例，并通过再建立一个新的 Jsp 类加载器来实现 JSP 文件的 HotSwap 功能。

- 

## 2.5 Java模块化系统todo

在JDK9中引入了模块化系统（JPMS）是对Java技术的重要升级为了能够实现模块化的关键目标，即可配置的封装隔离机制，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。JDK 9的模块不仅仅像之前的JAR 包那样只是简单地充当代码的容器，除了代码外，Java 的模块定义还包含以下内容:

- 依赖其他模块的列表。
- 导出的包列表，即其他模块可以使用的列表。 
- 开放的包列表，即其他模块可反射访问模块的列表
- 使用的服务列表。
- 提供服务的实现列表。

可配置的封装隔离机制首先要解决JDK 9之前基于类路径(ClassPath)来查找依赖的可靠性问题。此前，如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接时才会报出运行的异常。而在JDK 9以后，如果启用了模块化进行封装，模块就可以声明对其他模块的显式依赖，这样 Java 虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分由于类型依赖而引发的运行时异常。





# 三、虚拟机字节码执行引擎

## 3.1 概述

执行引擎是 Java 虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

在《Java虚拟机规范中》制定了Java虚拟机字节码执行引擎的概念模型，这个概念模型称为各大发行商的Java虚拟机执行引擎的统一外观。在不同的虚拟机实现下，执行引擎在执行字节码的时候，通常会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。但从外观上来看，所有的 Java 虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。

## 3.2 运行时栈帧结构

Java虚拟机以方法最为最基本的执行单元，栈帧则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的**虚拟机栈（VM Stack）的栈元素**。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回等信息。在Class文件结构中大多都能找到对照。每一个方法调用到执行结束，都对应着一个栈帧在虚拟机栈从入栈到出栈的过程。

每一个栈顿都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译 Java 程序源码的时候，栈中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的 Code 属性之中。

一个线程中的方法调用链可能会很长，以 Java 程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”(Current Stack Frame)，与这个栈所关联的方法被称为“当前方法”(CurrentMethod)。执行引擎所运行的所有字节码指令都只针对当前栈顿进行操作，在概念模型上，典型的栈帧结构如下图（图片来自《深入理解Java虚拟机周志明第三版》）：。

![image-20230421103844471](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230421103844471.png)

### 3.2.1 局部变量表

局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量，在Java程序被编译为Class文件时，就在Code属性的`max_locals`数据项中确定了该方法所需分配的局部变量表的最大容量。

**局部变量表以变量槽为最小单位**，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有引导性的说每个变量槽都应该存放一个`boolean,byte,cahr,short,int,float,reference或returnAddress`类型的数据，这八种数据类型都可以用32位或更小的物理内存来存储，但这种描述允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化，保证了即使在64位虚拟机中使用了64位的物理内存去实现一个变量槽，虚拟机仍要使用对齐或补白的手段，让变量槽在外观上看起来与32位虚拟机一致。

一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位的数据类型就是上面八种`boolean,byte,cahr,short,int,float,reference或returnAddress`。这八种可以按照Java语言对应的数据类型理解（只是理解，本质上是不一样的），而reference类型表示一个对象实例的引用，《Java虚拟机规范》并没有规定它的长度，也没有明确指出引用的结构，但一般来说，虚拟机实现至少应该通过这个应用完成两件事，一是根据引用直接或间接地查找对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属的数据类型在方法区中的存储的类型信息。第八种returnAddress已经很少见了，它是为字节码`jsr，jsr_w，ret`服务的，指向了一条字节码指令的地址，古老的虚拟机曾使用这几条指令完成异常处理的跳转，目前已经改为异常表来代替了。

对于64 位的数据类型，Java 虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。Java 语言中明确的64 位的数据类型只有 long和 double 两种。这里由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。

**Java 虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量**。如果访问的是 32 位数据类型的变量，索引N 就代表了使用第 N个变量槽，如果访问的是 64 位数据类型的变量，则说明会同时使用第 N和 N+1两个变量槽。对于两个相邻的共同存放一个64 位数据的两个量槽，虚拟机不允许采用任何方式单独访问其中的某一个，《Java 虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。

**当一个方法被调用时，Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递**。如果执行的是实例方法 (没有被 static 修饰的方法)，那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字`this`来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。为了节省栈帧耗用的内存空间，局部变量表的变量槽是可以重用的，方法体中的变量作用域有时不一定会覆盖整个方法体，如果当前字节码的PC计数器的值已经超过了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量重用，当然这种重用对于GC来说会有副作用，举个例子：

```java
public class Test {
    public static void main(String[] args) {
        //执行时增加-verbose:gc参数，查看GC情况
        byte [] bytes = new byte[64 * 1024 * 1024];
        System.gc();
    }
}
//结果：
//[GC (System.gc())  70738K->66643K(249344K), 0.0006828 secs]
//[Full GC (System.gc())  66643K->66480K(249344K), 0.0042080 secs]
```

从结果来看并没有进行GC，这也是能理解的，因为还没有出变量bytes作用域，下面我们进行修改：

```java
public class Test {
    public static void main(String[] args) {
        {
            byte [] bytes = new byte[64 * 1024 * 1024];
        }
        System.gc();
    }
}
//结果：
//[GC (System.gc())  70738K->66627K(249344K), 0.0035836 secs]
//[Full GC (System.gc())  66627K->66480K(249344K), 0.0195091 secs]
```

我们发现这时离开了作用域bytes还是没有被回收，下面再改一下：

```java
public class Test {
    public static void main(String[] args) {
        {
            byte [] bytes = new byte[64 * 1024 * 1024];
        }
        int a =0;
        System.gc();
    }
}
//结果：
//[GC (System.gc())  70738K->66643K(249344K), 0.0009406 secs]
//[Full GC (System.gc())  66643K->944K(249344K), 0.0041794 secs]
```

这时64M的bytes被回收了，这个问题的根本原因是：局部变量表中的变量槽是否保存关于bytes数组对象的引用，虽然加了代码块导致bytes离开了作用域，但是之后没有发生局部变量表的读写操作，所以bytes数组占用的变量槽还没有被其他变量复用，所以作为GC Roots一部分的局部变量表依旧保持的关联，所以它并没有被回收。

> 注意：虽然赋null值在在极端情况下，比如上面例子中是有效的，但是实际上以恰当的变量作用域来控制变量回收时间才是优雅的解决方法，且不同编译器可能会对代码进行优化，如果是即时编译器的话，赋null值可能会被当作无效操作消除掉。

同时局部变量表由于不像类变量一样存在准备阶段，所以不像类变量一样就算没有赋初始值也能用且不会产生歧义，所以局部变量如果没有初始值是完全不能使用的。

### 3.2.2 操作数栈

操作数栈也被称为操作栈，是一个后入先出（LIFO）的栈。同局部变量表一样，操作数栈的最大深度在编译的时候也会被写到Code属性的max_stacks数据项中，操作数栈的每一个元素都可以是包括 long 和 double 在内的任意Java 数据类型。32 位数据类型所占的栈容量为 1，64 位数据类型所占的容量为 2。Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在maxstacks 数据项中设定的最大值。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。比如在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的，比如在调用其他方法的时候是通过操作数栈来进行方法参数的传递。举个例子，例如整数加法的字节码指令 iadd，这条指今在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个 int 型的数值，当执行这个指令时，会把这两个 int 值出并相加，然后将相加的结果重新入栈。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。比如iadd不能出现一个值是int以外的其他数据类型。

另外在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈赖出现一部分重叠。让下面栈帧的部分操作数栈与上面栈顿的部分局部变量表重叠在一起，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了，如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230423115311728](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230423115311728.png)

Java 虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。

### 3.2.3 动态连接

每个栈帧都包含一个指向运行时常量池中该栈顿所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。由于Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

### 3.2.4 方法返回地址

当一个方法执行后，只有两种方式退出此方法，一是当执行引擎遇到任意一个方法返回的字节码指令，这时可能会与返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型由何种返回指令来决定，这种退出方式被称为正常调用完成。

另外一种就是遇到了异常，并且异常没有在方法体内处理。无论是JVM内部的异常，还是代码使用athrow字节码指令产生的异常，只要在本方法的异常表没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式被称为异常调用完成。使用这种方式，是不会给上层调用者提供任何返回值的。

无论怎么退出，当方法退出之后，都需要回到最初被调用的位置，程序才能继续进行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说，方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈中就一般不会保存这部分信息。

方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有:恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话) 压人调用者栈的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。注意以上退出过程只是概念模型，具体还是应该以JVM的具体实现为准。

### 3.2.5 附加信息

《Java 虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈顿之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。在讨论概念时，一般会把**动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息**。

## 3.3 方法调用

方法调用并不等于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），不涉及方法内部的具体过程。由于在Class编译过程不包含C/C++等程序语言的连接过程，所以一切方法调用在Class文件都是符号引用，而不是直接引用。这给Java带来了更强大的动态扩展能力，某些调用可能需要在类加载期间甚至运行期间才能确定目标方法的直接引用。

### 3.3.1 解析

所有的方法调用在Class文件中都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分转化为直接引用，但是这个前提是方法在程序运行前就有一个确定的可调用版本，并且这个方法的调用版本在运行期是不可改变的这类方法的调用被称为解析。

在Java中符合编译器可知，运行期不可变的主要有静态方法和私有方法两大类，这两类方法的特点决定了不会通过继承或者别的方式重写出其他版本的方法，因此适合类加载阶段进行解析。

调用不同类型的方法，字节码指令集里设计了不同的指令。在 Java 虚拟机支持以下5条方法调用字节码指令，分别是：

- `invokestatic`：用于调用静态方法。
- `invokespecial`：用于调用实例构造器`<init>()`方法、私有方法和父类中的方法。
- `invokevirtual`：用于调用所有的虚方法。
- `invokeinterface`：用于调用接口方法，会在运行时确定一个实现该接口的对象。
- `invokedynamic`：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在 Java 虚拟机内部，而`invokedynamic`指令的分派逻辑是由用户设定的引导方法来决定的。

只要能被`invokestatic`和`invokespecial`调用的方法，都可以在解析阶段确定唯一的调用版本，在Java中符合的有静态方法、私有方法、实例构造器、父类方法和被final修饰的方法（被final修饰的方法使用`invokevirtual`调用）。这5种方法调用会在类加载时将符号引用解析为直接引用，这些方法统称虚方法。相对应的其余的被称为非虚方法。

> Java 中的非虚方法除了使用`invokestatic`、`invokespeial` 调用的方法之外还有一种被 final修饰的实例方法。虽然由于历史设计的原因，final方法是使用 `invokevirtual`指令来调用的，但是因为它也无法被覆盖，没有其他版本的可能，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在《 Java 语言规范》中明确定义了被 final修饰的方法是一种非虚方法。

举个例子，比如下面的代码：

```java
public class Test {
    public static void helloWorld(){
        System.out.println("Hello World");
    }

    public static void main(String[] args) {
        Test.helloWorld();
    }
}
```

使用javap命令查看其调用的方法版本在编译时就以常量池项的形式固化在字节码指令的参数中：

![image-20230423142839572](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230423142839572.png)

### 3.3.2 分派

解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。而另一种主要的方法调用形式：分派(Dispatch) 调用则要复杂许多，它可能是静态的也可能是动态的按照分派依据的宗量数可分为*单分派和多分派*。这两类分派方式两两组合就构成了*静态单分派、静态多分派、动态单分派、动态多分派* 4种分派组合情况。

Java的面向对象三大特性是：继承、封装和多态，分派调用将会揭示多态性的基本体现，比如重载和重写在Java虚拟机是如何实现的。

#### 静态分派

我们先看下面的代码了解静态类型和实际类型的概念：

```java
public class StaticDispatch {
    static abstract class Human{
    }
    static class Man extends Human{
    }
    static class Woman extends Human{
    }
    public void hello(Human guy){
        System.out.println("hello guy");
    }
    public void hello(Man guy){
        System.out.println("hello boy");
    }
    public void hello(Woman guy){
        System.out.println("hello girl");
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch staticDispatch = new StaticDispatch();
        staticDispatch.hello(man);
        staticDispatch.hello(woman);
    }
}
```

它的运行结果是：

hello guy
hello guy

我们看这句代码  `Human man = new Man();`，其中Human被称为静态类型，Man被称为实际类型或者运行时类型。静态类型和实际类型在程序中都可能发生变化，区别是静态类型的变化仅在使用时发生，变量本身的静态类型不会被改变，最终的静态类型在编译期是可知的，而实际类型只有在运行期才能确定，程序编译时不知道对象的实际类型。我们举个例子：

~~~
//实际的类型变化
Human human = new Random().nextBoolean() ? new Man() : new Woman();
//静态类型变化
staticDispatch.hello((Man) human);
staticDispatch.hello((Woman) human);
~~~

对象human的实际类型是可变的，是Man还是Woman只有运行时才能知道，而human的静态类型是Human，也可以在使用时强转临时改变，但这个改变是编译期可知的。

了解了静态类型和实际类型的概念我们在看上面的代码，main的两次hello调用，在方法接收者已经确定是对象“staticDispatch”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。代码中故意定义了两个静态类型相同，而实际类型不同的变量，但**虚拟机(或者准确地说是编译器)在重载时是通过参数的静态类型而不是实际类型作为判定依据的**。由于静态类型在编译期可知，所以在编译阶段，Javac 编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main)方法里的两条invokevirtual指令的参数中。

这些所有依赖静态类型来决定方法执行版本的分派动作都成为静态分派。**静态分派的最典型应用表现就是方法重载。**静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，这点也是为何一些资料选择把它归入“解析”而不是“分派”的原因。

这里注意，分配与解析并不是排他关系，而是不同层次的筛选确定的过程。比如静态方法在编译期确定、在类加载期进行解析，而静态方法也可以重载，选择重载的版本过程也是静态分派完成的。

下面我们来看一下静态分派的例子，看一下方法重载时目标方法的选择过程：

```java
public class Test {
    public static void hello(Object arg){
        System.out.println("hello Object");
    }
    public static void hello(int arg){
        System.out.println("hello int");
    }
    public static void hello(long arg){
        System.out.println("hello long");
    }
    public static void hello(Character arg){
        System.out.println("hello Character");
    }
    public static void hello(char arg){
        System.out.println("hello char");
    }
    public static void hello(char ... arg){
        System.out.println("hello char ...");
    }
    public static void hello(Serializable arg){
        System.out.println("hello Serializable");
    }

    public static void main(String[] args) {
        hello('a');
        //运行结果：hello char
    }
}
```

输出`hello char`很好理解，但如果我们注释掉char的重载方法，这时就会输出：

![image-20230423151721707](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230423151721707.png)

这是因为发生了自动类型转换，`'a'`除了字符还可以代表数字97，我们继续注释，这时会输出：

![image-20230423151849260](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230423151849260.png)

这是因为从数字又被自动转换成长整数97L，匹配到了long的重载。这里没有写float、double等重载，但实际上自动重载还能发生很多：`char > int > long > float >double`。会按照这个顺序转换。然后我们继续注释掉long的重载方法：

![image-20230423152135716](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230423152135716.png)

我们可以看到这时又发生了一次自动装箱，然后我们继续注释：

![image-20230423152230355](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230423152230355.png)

这时会发现出现序列化了，这是因为Character类实现了Serializable接口

```java
public final
class Character implements java.io.Serializable, Comparable<Character>
```

由于找不到装箱类，所以找到了装箱类的实现接口，注意char可以转成int，但Character不能转成Integer。如果两个参数Serializable和Comparable的重载同时出现，那么编译器将拒绝编译，因为无法确定自动转型到哪种类型。

这时继续注释的话就会输出`hello Object`，因为char装箱后变成了父类，如果有多个父类，那就按照继承关系从下向上搜索。如果我们把Object的重载也注释掉，就会输出 `hello char ...`，可见可变长参数的重载优先级最低，这时`'a'`被当作`char[]`类型。

#### 动态分派

我们还是先看一段代码：

```java
public class DynamicDispatch {
    static abstract class Human {
        protected abstract void hello();
    }

    static class Man extends Human {
        @Override
        protected void hello() {
            System.out.println("boy says hello");
        }
    }

    static class Woman extends Human {
        @Override
        protected void hello() {
            System.out.println("girl says hello");
        }
    }

    public void hello(Human guy) {
        System.out.println("hello guy");
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.hello();
        woman.hello();
        man = new Woman();
        man.hello();
    }
}
//运行结果：
//boy says hello
//girl says hello
//girl says hello
```

然后我们javap查看字节码指令：

![image-20230423153423859](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230423153423859.png)

其中0-15行对应着 `Human man = new Man();Human woman = new Woman();`，接下来16行和20行的aload指令分别把刚创建的俩对象压到栈顶，这两个对象是hello方法的所有者，称为接收者；17和21行是方法调用指令，这两个指令从字节码角度来看无论是`invokevirtual`还是参数上图中对应着常量池`#9`都完全一样，但是这两句指令的执行的方法不同，所以弄清楚如何确定方法版本、如何实现多态还是要从 `invokevirtual`指令入手。

> 上面的#9如下：
>
>  `#9 = Methodref          #15.#44        // com/learn/jvmtest/DynamicDispatch$Human.hello:()V`

`invokevirtual`指令的解析过程大致如下：

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作 C。
2. 如果在类型 C 中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回`java.lang.IllegalAccessError` 异常
3. 否则，按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程。
4. 如果始终没有找到合适的方法，则抛出`java.lang.AbstractMethodError` 异常。

正是因为 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual 指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是 Java 语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为**动态分派**。

这种多态性的根源在于虚方法调用指令 `invokevirtual`的执行逻辑，且只会对方法有效，对字段是无效的，因为字段不使用这条指令。事实上，在Java 里面只有虚方法存在，字段永远不可能是虚的，换句话说，字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。

#### 单分派与多分派

方法的接收者和方法的参数统称为方法的宗量，这个定义最早来自于《Java与模式》。我们可以将分派划分为单分派与多分派。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。举个例子：

> 这个例子的梗在[这是一个艰难的决定](https://zhuanlan.zhihu.com/p/19609988)，周志明大佬带你重温老梗doge。

```java
public class Test {

    static class QQ{}
    static class _360{}

    public static class Father{
        public void hardChoice(QQ arg){
            System.out.println("father choose QQ");
        }
        public void hardChoice(_360 arg){
            System.out.println("father choose 360");
        }
    }

    public static class Son extends Father{
        public void hardChoice(QQ arg){
            System.out.println("son choose QQ");
        }
        public void hardChoice(_360 arg){
            System.out.println("son choose 360");
        }
    }

    public static void main(String[] args) {
        Father father = new Father();
        Father son = new Son();
        father.hardChoice(new _360());
        son.hardChoice(new QQ());
    }
}
//运行结果：
//father choose 360
//son choose QQ
```

上面的代码中，在main中调用了两次hardChoice方法。先关注静态分派：在静态分派的过程中选择目标方法的依据有两点：一是静态类型是 Father 还是 Son；二是方法参数是QQ还是360。这次选择结果的最终产物是产生了两条 `invokevirtual` 指令，两条指令的参数分别为常量池中指向 `Father::hardChoice(360)`及 `Father::hardChoice(QQ)`方法的符号引用。因为是根据两个宗量进行选择，所以 Java 语言的静态分派属于多分派类型。

再看动态分派在执行`son.hardChoice(new QQ())`这行代码时，更准确地说，是在执行这行代码所对应的 `invokevirtual` 指令时，由于编译期已经决定目标方法的签名必须为 `hardChoice(QQ)`，虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯 QQ”还是“奇瑞 QQ”，因为这时候参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的接受者的实际类型是 Father 还是 Son。因为只有一个宗量作为选择依据，所以 Java 语言的动态分派属于单分派类型。

因此可以说Java是一门静态多分派，动态单分派的语言。

#### 虚拟机动态分派的实现

动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法，因此，Java 虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表(Virtual Method Table，也称为vtable，与此对应的，在invokeinterface 执行时也会用到接口方法表Interface MethodTable，简称 itable)，使用虚方法表索引来代替元数据查找以提高性能。虚方法表结构如下：

![image-20230423161522280](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230423161522280.png)

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。在上图中，Son 重写了来自 Father 的全部方法，因此 Son 的方法表没有指向 Father 类型数据的箭头。但是 Son 和 Father 都没有重写来自 Obiect 的方法，所以它们的方法表中所有从 Object 继承来的方法都指向了 Object 的数据类型。

查虚方法表是分派调用的一种优化手段，由于 Java 对象里面的方法默认(即不使用 final 修饰)就是虚方法，虚拟机除了使用虚方法表之外，为了进一步提高性能，还会使用类型继承关系分析(Class Hierarchy Analysis，CHA)、守护内联(GuardedInlining)、内联缓存(Inline Cache)等多种非稳定的激进优化来争取更大的性能空间。

## 3.4 动态类型语言支持todo

## 3.5 基于栈的字节码解释执行引擎

许多Java虚拟机的执行引擎在执行Java代码都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。这里我们学习一下在概念模型下的Java虚拟机解释执行字节码时，执行引擎是如何工作的。

> 注意这里仅是概念模型，因为实际的虚拟机实现并不是概念模型一板一眼的机械式计算，而是动态产生每条字节码的汇编代码运行。

### 3.5.1 解释执行

在 Java 初生的JDK 1.0 时代，解释执行还算是比较准确的，但当主流的虚拟机中都包含了即时编译器后，Class 文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事。只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较合理确切。

无论是解释还是编译，也无论是物理机还是虚拟机，对于应用程序，机器都不可能如人那样阅读、理解，然后获得执行能力。大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图的各个步骤，图片来自《深入理解Java虚拟机周志明第三版》：

![image-20230423163417124](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230423163417124.png)

如今，基于物理机、Java 虚拟机，或者是非 Java 的其他高级语言虚拟机(HLLVM)的代码执行过程，大体上都会遵循这种符合现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树(Abstract Syntax Tree，AST)。对于一门具体语言的实现来说，词法、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是 C/C++ 语言。也可以选择把其中一部分步骤(如生成抽象语法树之前的步骤) 实现为一个半独立的编译器这类代表是 Java 语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的JavaScript 执行引擎。
在Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。

### 3.5.2 基于栈的指令集和基于寄存器的指令集



### 3.5.3 基于栈的解释器的执行过程

# 四、附录

## 4.1 十七种种常量类型结构

![image-20230419150836072](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419150836072.png)

![image-20230419150903308](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419150903308.png)

![image-20230419150916099](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419150916099.png)

## 4.2 虚拟机规范预定义的属性

> 本小节内容来自：
>
> - 《深入理解Java虚拟机周志明第三版》
> - [Class类文件结构解析](http://www.taodudu.cc/news/show-4748638.html)

![image-20230419164010045](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419164010045.png)

![image-20230419164036952](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419164036952.png)

下面举例说明部分属性定义，这里不展示全部，如有需要请自行百度。

### 4.2.1 Code属性

 Code属性是Class文件中最重要的属性，如果把Java程序信息分为代码（Java代码）和元数据（包括类、字段、方法及其他信息），那么Code属性就是用来描述代码的，而其他所有数据项目都是在描述元数据。

Code属性结构如下

| 类型           | 名称                   | 数量             | 含义                     |
| -------------- | ---------------------- | ---------------- | ------------------------ |
| u2             | attribute_name_index   | 1                | 属性名索引               |
| u4             | attribute_length       | 1                | 属性长度                 |
| u2             | max_stack              | 1                | 操作数栈深度的最大值     |
| u2             | max_locals             | 1                | 局部变量表所需的存续空间 |
| u4             | code_length            | 1                | 字节码指令的长度         |
| u1             | code                   | code_length      | 存储字节码指令           |
| u2             | exception_table_length | 1                | 异常表长度               |
| exception_info | exception_table        | exception_length | 异常表                   |
| u2             | attributes_count       | 1                | 属性集合计数器           |
| attribute_info | attributes             | attributes_count | 属性集合                 |

部分类型说明：

- attribute_name_index:一项指向CONSTANT_Utf8_info型常量的索引，该常量固定为"Code"，代表了该属性的名称。
- max_stack：操作数栈深度最大值，在方法执行的任意时刻，操作数栈都不会超过这个深度。
- max_locals: 局部变量表所需存储空间，单位为变量槽（Slot），Slot是JVM为局部变量分配内存的最小单位。
- code_length：虽然是u4，但由于JVM规定方法不允许超过65535条字节码指令，所以只用了u2.

### 4.2.2 Exceptions属性

Exceptions属性属于方法表，与Code属性平级，**作用是列举出方法中可能抛出的受查异常，也就是方法描述时throws关键词之后的异常**。结构如下。这和Code属性中的Exception table不一样，Code异常表是用来处理异常，实现finally处理机制的。

| 类型 | 名称                  | 数量                |
| ---- | --------------------- | ------------------- |
| u2   | attribute_name_index  | 1                   |
| u4   | attribute_length      | 1                   |
| u2   | number_of_exceptions  | 1                   |
| u2   | exception_index_table | number_of_exception |

### 4.2.3 LineNumberTable属性

LineNumberTable属性是用来描述Java源码行号与字节码行号之间的对应关系。**通过两者的对应关系，当发生异常时，JVM可以准确的定义到是源码的哪行出现的错误。**

| 类型             | 名称                     | 数量                     | 含义       |
| ---------------- | ------------------------ | ------------------------ | ---------- |
| u2               | attribute_name_index     | 1                        | 属性名索引 |
| u4               | attribute_length         | 1                        | 属性长度   |
| u2               | line_number_table_length | 1                        | 行号表长度 |
| line_number_info | line_number_table        | line_number_table_length | 行号表     |

### 4.2.4 LocalVariableTable及LocalVariableTypeTable属性

LocalVariableTable用于描述栈帧种局部变量表的变量与Java源码中变量的关系，它也不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在Javac 中使用-g:none 或-g:vars 选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如 IDE 将会使用诸如 arg0、argl之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。

LocalVariableTable属性结构如下图：

![image-20230419170005773](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419170005773.png)

其中`local_variable_table`代表了一个栈帧与源码中的局部变量的关系，结构如下图：

![image-20230419170112605](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230419170112605.png)

### 4.2.5 SourceFile属性

attribute_name_index属性名索引指向常量池中的”SourceFile“字符串常量，sourcefile_index数据项指向常量池中CONSTANT_Utf8_info型常量索引，常量值是源码文件的文件名，通常类名和文件名是一致的，但也有一些特殊情况，比如内部类。

| 类型 | 名称                 | 数量 | 含义         |
| ---- | -------------------- | ---- | ------------ |
| u2   | attribute_name_index | 1    | 属性名索引   |
| u4   | attribute_length     | 1    | 属性长度     |
| u2   | sourcefile_index     | 1    | 源码文件索引 |
