# Java零拷贝学习笔记

转载请声明！！！侵权必究。本文如有错误，欢迎指正。

> 参考资料：
>
> - 《Java高并发核心编程卷一》
> - https://blog.csdn.net/weixin_39406430/article/details/123715072
> - https://zhuanlan.zhihu.com/p/308054212
> - 《葵花宝典》尼恩

## 一、IO读写原理

### 1.1 内核态、用户态、内核空间、用户空间

为了避免用户进程直接操作内核，操作系统将内存分为内核空间和用户空间。在Linux中内核模块运行在内核空间，对应的进程处于内核态，用户程序运行在用户空间，对应的进程处于用户态。也可以理解为当进程运行在内核空间时就处于**内核态**，当进程运行在用户空间时就处于**用户态**。内核态进程可以执行任何命令调用一切资源，而用户态进程只能执行简单的运算，不能直接调用系统资源。**如果用户态进程需要调用系统资源，就需要调用系统接口进行系统调用，才能向内核发出指令，完成系统资源的调用。**

> 用户态切换内核态的方式：
>
> - **系统调用**：用户进程主动发起的操作。用户态进程发起系统调用主动要求切换到内核态，陷入内核之后，由操作系统来操作系统资源，完成之后再返回到进程。
> - **异常**：被动的操作，且用户进程无法预测其发生的时机。当用户进程在运行期间发生了异常（比如某条指令出了问题），这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也即是切换到了内核态。异常包括程序运算引起的各种错误如除 0、缓冲区溢出、缺页等。
> - **中断**：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令是用户态下的程序，那么转换的过程自然就会是从用户态到内核态的切换。中断包括 I/O 中断、外部信号中断、各种定时器引起的时钟中断等。中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。

内核是操作系统的核心，它可以访问受保护的内核空间，也可以访问底层硬件设备。内核空间是操作系统为内核保留的，它总是驻留在内存中，应用程序不允许直接在内核空间区域进行读写，也不允许直接调用内核代码定义函数。每个应用程序进程都有一个单独的用户空间，对应于进程处于用户态，进行系统调用时，需要将进程切换到内核态。

### 1.2 内核缓冲区和进程缓冲区

当用户程序进行IO读写时，实际上依赖于底层的IO读写，也就是会用到底层的read和write系统调用（不同操作系统可能名称不同）。操作系统的read系统调用并不是从物理设备将数据读取到应用内存中，write系统调用也是如此，无论是哪个系统调用都设计到缓冲区，也就是说read系统调用时，实际上是将数据从内核缓冲区复制到应用程序的进程缓冲区中，write系统调用是将数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区中。简单理解就是，read和write系统调用实际上是缓存的复制。而底层与物理设备的读写操作由内核完成。

那么设置缓冲区的作用是什么？其实是为了减少与设备间的频繁的物理交换。计算机外部物理设备与内存和CPU相比有很大区别，外部设备读写需要涉及到操作系统的中断。系统中断时需要保存中断前的相关信息，中断后还需要进行恢复。因此为了减少频繁的中断于是有了内核缓冲区。这样就可以等到缓冲区到达一定数量在集中进行IO操作，提升性能，这一切都由内核决定。在Linux系统中，只有一个内核缓冲区。

### 1.3 C程序的IO

> DMA 全称是 Direct Memory Access，也即直接存储器存取，是一种用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。整个过程无须 CPU 参与，数据直接通过 DMA 控制器进行快速地移动拷贝，节省 CPU 的资源去做其他工作。
>
> 目前，大部分的计算机都配备了 DMA 控制器，而 DMA 技术也支持大部分的外设和存储器。借助于 DMA 机制，计算机的 I/O 过程就能更加高效。

一次完整的IO流程如下(这里不考虑IO模型，均以阻塞式IO为例)，图片参考Java高并发核心编程卷一绘制：

![image-20221114110641221](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114110641221.png)

1. 首先用户程序通过write/read库方法启动IO操作

2. 如果是写操作就调用sys_write内核函数，进程从用户态切换成内核态，将用户内存数据复制到内核空间，这是一次CPU复制。如果是读操作，调用内核函数后，进程从用户态切换成内核态，在阻塞式IO模式下，用户进程等待系统调用返回。系统等待内核缓冲区的数据。

   如果该内核缓冲区与套接字相关，叫做socket send buffer，如果与文件系统相关，叫做file system cache

   > 用户程序所使用的read和write函数，可以理解为C语言中的库函数，这个库函数专供用户程序使用。注意：这些库函数并不是内核程序，而内核空间的数据读写需要内核程序完成，所以，这些库函数里，还需要对系统调用进行更进一步的封装和调用。
   >
   > 其实可以简单理解为C程序中使用的read库函数会调用到的系统调用为sys_read，由sys_read完成内核空间的数据读取；用户C程序中使用的write库函数会调用到的系统调用为sys_write，由sys_write完成内核空间的数据写入。

3. 如果是写操作数据就通过DMA从内核缓冲区拷贝到网卡或文件系统。

   如果是读操作，DMA读取网卡或文件内容，将其存储到内核缓冲区。

4. 如果是写操作则系统调用返回，进程从内核态切换回用户态，读操作同理。

   如果是读操作则sys_read内核函数将数据从内核缓冲区复制到用户缓冲区，系统调用返回。

### 1.4 Java程序的IO

我们在了解一下在Java中一次完整的IO是什么样的，流程如下（图片参考Java高并发核心编程卷一绘制）：

![image-20221114112348754](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114112348754.png)

如上图，Java程序进行IO操作时会多一次CPU复制的过程，也就是JVM堆内外的数据拷贝。

在linux系统中，JVM也是一个普通的linux程序，且JVM属于C程序，因此Java堆内存实际上可以理解为一个C++对象。我们这里将Java堆内存称为Java堆，之外的堆内存称为C堆。

其实二者区别不大，因为Java堆也可以理解为C堆的一部分，二者的读写效率差不多，但是Java堆有一个很重要的特性，就是GC。由于JVM在GC时可能对移动对象的地址，因此Java对象的地址并不是固定的。由于JVM只是一个普通的用户程序，且GC时会移动对象的的地址，而内核无法感知到这种移动，因此我们在进行IO操作时，需要先将数据拷贝到不受JVM堆控制的堆外内存中，这就是C堆，比如Java中的DIrectByteBuffer就在这个区域。同样，read的时候，我们也要保证系统往缓冲区写入时，不能GC移动内存，因此我们必须要进行一次堆内外拷贝。



## 二、零拷贝

传统的IO流程会进行CPU复制，且会进行内核态和用户态的转换，这也会带来上下文切换的系统开销。因此我们需要零拷贝（zore copy）。

零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，进而减少上下文切换以及CPU的拷贝时间。它是一种IO操作优化技术。零拷贝的优势如下：

- 减少甚至避免操作系统内核缓冲区和用户缓冲区之间的数据拷贝，从而减少内核态用户态切换，或者说内核态用户态切换导致的上下文切换带来的系统开销。
- 减少甚至避免操作系统内核缓冲区之间的数据拷贝操作。

实现zore copy的主要方式有mmap和sendfile。在Java中使用直接内存也可以算是零拷贝优化。

### 2.1 DirectBuffer

我们先来看直接内存的IO流程（图片参考Java高并发核心编程卷一绘制）：

![image-20221114132143340](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114132143340.png)

其实，这个流程与C程序的IO复制差不多，因为使用了直接内存或者说是堆外内存，因此可以节省一次CPU复制即堆内外复制的过程。

### 2.2 mmap+write

`mmap()` 也即是内存映射（memory map）：把用户进程空间的一段内存缓冲区（user buffer）映射到文件所在的内核缓冲区（kernel buffer）上。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap在用户空间映射调用系统中作用很大。下面来看一下mmap的文件IO流程（图片参考Java高并发核心编程卷一绘制）：

![image-20221114134655866](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114134655866.png)

mmap主要作用是替换read操作，其文件IO流程主要如上图：

1. Java程序调用mmap方法，调用底层封装的mmap系统调用
2. 用户进程调用mmap系统调用，让用户态进入到内核态，同时将，内核缓冲区映射到用户缓冲区
3. 然后DMA将数据在内核缓冲区和磁盘文件中进行拷贝

由于完成了文件映射，因此后续操作只需要对用户缓冲区进行操作即可，DMA会进行延时拷贝，完成数据的IO。

当然，上面只是对文件的IO操作，对于网络IO，mmap需要配合write操作完成IO，流程如下：

![image-20221114135219431](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114135219431.png)

1. 用户进程调用 mmap()，从用户态陷入内核态，将内核缓冲区映射到用户缓存区；
2. DMA 控制器将数据从硬盘拷贝到内核缓冲区；
3. mmap() 返回，上下文从内核态切换回用户态；
4. 用户进程调用 write()，尝试把文件数据写到内核里的套接字缓冲区，再次陷入内核态；
5. CPU 将内核缓冲区中的数据拷贝到的套接字缓冲区；
6. DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；
7. write()返回，上下文从内核态切换回用户态。

通过这种方式，有两个优点：一是节省内存空间，因为用户进程上的这一段内存是虚拟的，并不真正占据物理内存，只是映射到文件所在的内核缓冲区上，因此可以节省一半的内存占用；二是省去了一次 CPU 拷贝，对比传统的 Linux I/O 读写，数据不需要再经过用户进程进行转发了，而是直接在内核里就完成了拷贝。

### 2.3 sendfile

下面我们来了解一下sendfile零拷贝技术。Linux2.1中引入了sendfile()，现在只通过这一个系统调用即可实现文件发送，也就是说它可以代替mmap+write，流程如下：

![image-20221114135802418](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114135802418.png)

1. 用户进程调用sendfile() 从用户态陷入内核态；
2. DMA 控制器将数据从硬盘拷贝到内核缓冲区；
3. CPU 将内核缓冲区中的数据拷贝到套接字缓冲区；
4. DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；
5. sendfile() 返回，上下文从内核态切换回用户态。

也就是说这种方式对比mmap+write可以省略一次系统调用。但是这样还是有一次CPU复制，因此在Linux 在内核 2.4 版本里引入了 DMA 的 scatter/gather -- 分散/收集功能，并修改了 sendfile()`的代码使之和 DMA 适配。scatter 使得 DMA 拷贝可以不再需要把数据存储在一片连续的内存空间上，而是允许离散存储，gather 则能够让 DMA 控制器根据少量的元信息：一个包含了内存地址和数据大小的缓冲区描述符，收集存储在各处的数据，最终还原成一个完整的网络包，直接拷贝到网卡而非套接字缓冲区，避免了最后一次的 CPU 拷贝

## 三、NIO原理

3.1 DirectBuffer源码分析

3.2 DirectBuffer内存回收源码分析

3.3 DirectBuffer内存泄露问题

3.4 DirectBuffer的常见问题

3.5 
