# Java零拷贝学习笔记

转载请声明！！！侵权必究。本文如有错误，欢迎指正。

> 参考资料：
>
> - 《Java高并发核心编程卷一》
> - https://blog.csdn.net/weixin_39406430/article/details/123715072
> - https://zhuanlan.zhihu.com/p/308054212
> - 《葵花宝典》尼恩
> - https://cloud.tencent.com/developer/article/1811639

## 一、IO读写原理

### 1.1 内核态、用户态、内核空间、用户空间

为了避免用户进程直接操作内核，操作系统将内存分为内核空间和用户空间。在Linux中内核模块运行在内核空间，对应的进程处于内核态，用户程序运行在用户空间，对应的进程处于用户态。也可以理解为当进程运行在内核空间时就处于**内核态**，当进程运行在用户空间时就处于**用户态**。内核态进程可以执行任何命令调用一切资源，而用户态进程只能执行简单的运算，不能直接调用系统资源。**如果用户态进程需要调用系统资源，就需要调用系统接口进行系统调用，才能向内核发出指令，完成系统资源的调用。**

> 用户态切换内核态的方式：
>
> - **系统调用**：用户进程主动发起的操作。用户态进程发起系统调用主动要求切换到内核态，陷入内核之后，由操作系统来操作系统资源，完成之后再返回到进程。
> - **异常**：被动的操作，且用户进程无法预测其发生的时机。当用户进程在运行期间发生了异常（比如某条指令出了问题），这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也即是切换到了内核态。异常包括程序运算引起的各种错误如除 0、缓冲区溢出、缺页等。
> - **中断**：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令是用户态下的程序，那么转换的过程自然就会是从用户态到内核态的切换。中断包括 I/O 中断、外部信号中断、各种定时器引起的时钟中断等。中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。

内核是操作系统的核心，它可以访问受保护的内核空间，也可以访问底层硬件设备。内核空间是操作系统为内核保留的，它总是驻留在内存中，应用程序不允许直接在内核空间区域进行读写，也不允许直接调用内核代码定义函数。每个应用程序进程都有一个单独的用户空间，对应于进程处于用户态，进行系统调用时，需要将进程切换到内核态。

### 1.2 内核缓冲区和进程缓冲区

当用户程序进行IO读写时，实际上依赖于底层的IO读写，也就是会用到底层的read和write系统调用（不同操作系统可能名称不同）。操作系统的read系统调用并不是从物理设备将数据读取到应用内存中，write系统调用也是如此，无论是哪个系统调用都设计到缓冲区，也就是说read系统调用时，实际上是将数据从内核缓冲区复制到应用程序的进程缓冲区中，write系统调用是将数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区中。简单理解就是，read和write系统调用实际上是缓存的复制。而底层与物理设备的读写操作由内核完成。

那么设置缓冲区的作用是什么？其实是为了减少与设备间的频繁的物理交换。计算机外部物理设备与内存和CPU相比有很大区别，外部设备读写需要涉及到操作系统的中断。系统中断时需要保存中断前的相关信息，中断后还需要进行恢复。因此为了减少频繁的中断于是有了内核缓冲区。这样就可以等到缓冲区到达一定数量在集中进行IO操作，提升性能，这一切都由内核决定。在Linux系统中，只有一个内核缓冲区。

### 1.3 C程序的IO

> DMA 全称是 Direct Memory Access，也即直接存储器存取，是一种用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。整个过程无须 CPU 参与，数据直接通过 DMA 控制器进行快速地移动拷贝，节省 CPU 的资源去做其他工作。
>
> 目前，大部分的计算机都配备了 DMA 控制器，而 DMA 技术也支持大部分的外设和存储器。借助于 DMA 机制，计算机的 I/O 过程就能更加高效。

一次完整的IO流程如下(这里不考虑IO模型，均以阻塞式IO为例)，图片参考Java高并发核心编程卷一绘制：

![image-20221114110641221](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114110641221.png)

1. 首先用户程序通过write/read库方法启动IO操作

2. 如果是写操作就调用sys_write内核函数，进程从用户态切换成内核态，将用户内存数据复制到内核空间，这是一次CPU复制。如果是读操作，调用内核函数后，进程从用户态切换成内核态，在阻塞式IO模式下，用户进程等待系统调用返回。系统等待内核缓冲区的数据。

   如果该内核缓冲区与套接字相关，叫做socket send buffer，如果与文件系统相关，叫做file system cache

   > 用户程序所使用的read和write函数，可以理解为C语言中的库函数，这个库函数专供用户程序使用。注意：这些库函数并不是内核程序，而内核空间的数据读写需要内核程序完成，所以，这些库函数里，还需要对系统调用进行更进一步的封装和调用。
   >
   > 其实可以简单理解为C程序中使用的read库函数会调用到的系统调用为sys_read，由sys_read完成内核空间的数据读取；用户C程序中使用的write库函数会调用到的系统调用为sys_write，由sys_write完成内核空间的数据写入。

3. 如果是写操作数据就通过DMA从内核缓冲区拷贝到网卡或文件系统。

   如果是读操作，DMA读取网卡或文件内容，将其存储到内核缓冲区。

4. 如果是写操作则系统调用返回，进程从内核态切换回用户态，读操作同理。

   如果是读操作则sys_read内核函数将数据从内核缓冲区复制到用户缓冲区，系统调用返回。

### 1.4 Java程序的IO

我们在了解一下在Java中一次完整的IO是什么样的，流程如下（图片参考Java高并发核心编程卷一绘制）：

![image-20221114112348754](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114112348754.png)

如上图，Java程序进行IO操作时会多一次CPU复制的过程，也就是JVM堆内外的数据拷贝。

在linux系统中，JVM也是一个普通的linux程序，且JVM属于C程序，因此Java堆内存实际上可以理解为一个C++对象。我们这里将Java堆内存称为Java堆，之外的堆内存称为C堆。

其实二者区别不大，因为Java堆也可以理解为C堆的一部分，二者的读写效率差不多，但是Java堆有一个很重要的特性，就是GC。由于JVM在GC时可能对移动对象的地址，因此Java对象的地址并不是固定的。由于JVM只是一个普通的用户程序，且GC时会移动对象的的地址，而内核无法感知到这种移动，因此我们在进行IO操作时，需要先将数据拷贝到不受JVM堆控制的堆外内存中，这就是C堆，比如Java中的DirectByteBuffer就在这个区域。同样，read的时候，我们也要保证系统往缓冲区写入时，不能GC移动内存，因此我们必须要进行一次堆内外拷贝。

### 1.5 NIO文件传输过程原理



## 二、零拷贝

传统的IO流程会进行CPU复制，且会进行内核态和用户态的转换，这也会带来上下文切换的系统开销。因此我们需要零拷贝（zore copy）。

零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，进而减少上下文切换以及CPU的拷贝时间。它是一种IO操作优化技术。零拷贝的优势如下：

- 减少甚至避免操作系统内核缓冲区和用户缓冲区之间的数据拷贝，从而减少内核态用户态切换，或者说内核态用户态切换导致的上下文切换带来的系统开销。
- 减少甚至避免操作系统内核缓冲区之间的数据拷贝操作。

实现zore copy的主要方式有mmap和sendfile。在Java中使用直接内存也可以算是零拷贝优化。

### 2.1 DirectBuffer

我们先来看直接内存的IO流程（图片参考Java高并发核心编程卷一绘制）：

![image-20221114132143340](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114132143340.png)

其实，这个流程与C程序的IO复制差不多，因为使用了直接内存或者说是堆外内存，因此可以节省一次CPU复制即堆内外复制的过程。

### 2.2 mmap+write

`mmap()` 也即是内存映射（memory map）：把用户进程空间的一段内存缓冲区（user buffer）映射到文件所在的内核缓冲区（kernel buffer）上。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap在用户空间映射调用系统中作用很大。下面来看一下mmap的文件IO流程（图片参考Java高并发核心编程卷一绘制）：

![image-20221114134655866](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114134655866.png)

mmap主要作用是替换read操作，其文件IO流程主要如上图：

1. Java程序调用mmap方法，调用底层封装的mmap系统调用
2. 用户进程调用mmap系统调用，让用户态进入到内核态，同时将，内核缓冲区映射到用户缓冲区
3. 然后DMA将数据在内核缓冲区和磁盘文件中进行拷贝

由于完成了文件映射，因此后续操作只需要对用户缓冲区进行操作即可，DMA会进行延时拷贝，完成数据的IO。

当然，上面只是对文件的IO操作，对于网络IO，mmap需要配合write操作完成IO，流程如下：

![image-20221114135219431](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114135219431.png)

1. 用户进程调用 mmap()，从用户态陷入内核态，将内核缓冲区映射到用户缓存区；
2. DMA 控制器将数据从硬盘拷贝到内核缓冲区；
3. mmap() 返回，上下文从内核态切换回用户态；
4. 用户进程调用 write()，尝试把文件数据写到内核里的套接字缓冲区，再次陷入内核态；
5. CPU 将内核缓冲区中的数据拷贝到的套接字缓冲区；
6. DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；
7. write()返回，上下文从内核态切换回用户态。

通过这种方式，有两个优点：一是节省内存空间，因为用户进程上的这一段内存是虚拟的，并不真正占据物理内存，只是映射到文件所在的内核缓冲区上，因此可以节省一半的内存占用；二是省去了一次 CPU 拷贝，对比传统的 Linux I/O 读写，数据不需要再经过用户进程进行转发了，而是直接在内核里就完成了拷贝。

### 2.3 sendfile

下面我们来了解一下sendfile零拷贝技术。Linux2.1中引入了sendfile()，现在只通过这一个系统调用即可实现文件发送，也就是说它可以代替mmap+write，流程如下：

![image-20221114135802418](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221114135802418.png)

1. 用户进程调用sendfile() 从用户态陷入内核态；
2. DMA 控制器将数据从硬盘拷贝到内核缓冲区；
3. CPU 将内核缓冲区中的数据拷贝到套接字缓冲区；
4. DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；
5. sendfile() 返回，上下文从内核态切换回用户态。

也就是说这种方式对比mmap+write可以省略一次系统调用。但是这样还是有一次CPU复制，因此在Linux 在内核 2.4 版本里引入了 DMA 的 scatter/gather -- 分散/收集功能，并修改了 sendfile()`的代码使之和 DMA 适配。scatter 使得 DMA 拷贝可以不再需要把数据存储在一片连续的内存空间上，而是允许离散存储，gather 则能够让 DMA 控制器根据少量的元信息：一个包含了内存地址和数据大小的缓冲区描述符，收集存储在各处的数据，最终还原成一个完整的网络包，直接拷贝到网卡而非套接字缓冲区，避免了最后一次的 CPU 拷贝

## 三、DirectBuffer原理

### 3.1 DirectBuffer源码分析

在分析源码之前，我们先来了解一下DirectBuffer的本质，其本质实际上可以用冰山来比喻，也就是说在JVM堆内部的实际上只是一个引用，真正的对象实际上在直接内存中，在JVM堆内的只是该对象的冰山一角，如下图：

![image-20221120180442406](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221120180442406.png)

下面我们通过一个小例子来看一下DirectBuffer的使用：

```java
public static void main(String[] args) {
    //创建DirectBuffer
    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
    for (int i = 0; i < 5; i++) {
        buffer.putInt(i);

    }
    buffer.flip();
    for (int i = 0; i < 5; i++) {
        int j = buffer.getInt();
        System.out.println(j);
    }
}
```

从上面我们可以看到直接内存是通过allocateDirect方法创建的。下面我们就从这里入手看一下DirectBuffer的创建和使用的源码。首先我们跟进allocateDirect方法：

```java
public static ByteBuffer allocateDirect(int capacity) {
    return new DirectByteBuffer(capacity);
}
```

可以看到我们通过此方法创建DirectBuffer本质上就是通过new调用构造函数返回了一个DirectBuffer对象。我们跟进去：

```java
// Primary constructor
//
DirectByteBuffer(int cap) {                   // package-private

    super(-1, 0, cap, cap);
    boolean pa = VM.isDirectMemoryPageAligned();//是否是页对齐
    int ps = Bits.pageSize();//获取页大小
    long size = Math.max(1L, (long)cap + (pa ? ps : 0));//如果是页对齐就加上上一页的大小
    Bits.reserveMemory(size, cap);//判断空间是否足够；清理空间；记录分配的直接内存

    long base = 0;
    try {
        //分配内存
        base = unsafe.allocateMemory(size);
    } catch (OutOfMemoryError x) {
        Bits.unreserveMemory(size, cap);
        throw x;
    }
    //初始化内存
    unsafe.setMemory(base, size, (byte) 0);
    if (pa && (base % ps != 0)) {
        // Round up to page boundary
        address = base + ps - (base & (ps - 1));
    } else {
        address = base;
    }
    //生成cleaner清理对象
    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
    att = null;
}
```

> 直接内存创建时判断是否是页对齐(内存对齐意味将数据类型写入到内存地址时是按照它们大小切割的，内存对齐会带来性能提升，是Java性能提升的黑技术)，如果是页对齐就加上上一页的大小，关于`VM.isDirectMemoryPageAligned()`方法可以查看jdk源码，如下：
>
> ![image-20221121101524701](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221121101524701.png)

我们可以看到DirectBuffer的构造函数是包私有的，所以我们创建时只能通过allocateDirect方法进行创建。在此构造函数中,实际上我们是通过unsafe类的allocateMemory方法来分配内存的，此方法本质上是一个native方法，是通过C的malloc来进行分配的，C++源码如下图[unsafe.cpp源码](https://github.com/openjdk/jdk8/blob/master/hotspot/src/share/vm/prims/unsafe.cpp)：

![image-20221121110013072](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221121110013072.png)

`Bits.reserveMemory`方法会尝试完成本次堆外内存的创建（源码在3.2进行分析），尝试步骤如下：

- 触发一次`Reference#tryHandlePending`方法，将已经被JVM回收的DirectBuffer的堆外内存释放
- 如果内存还不够则触发full gc具体是使用System.gc()方法触发。但调用System.gc()不能保证马上进行full gc，所以后面的代码会继续尝试9次，看看是否有足够的内存完成此次内存分配
- 如果9次后还不能完成此次内存分配则抛出oom。

> 为什么这里通过full gc尝试回收堆外内存？
>
> 事实上，执行`System.gc()`，是期望触发`full gc`，来回收堆内存中的`DirectByteBuffer`对象来触发堆外内存回收.

以上就是堆外内存的创建流程源码分析。DirectByteBuffer是Java用于实现堆外内存的一个重要类，我们可以通过该类实现堆外内存的创建、使用和销毁。我们怎么通过对象操作堆外内存呢？我们看一下他的继承关系：

![image-20221121103414234](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221121103414234.png)

在DirectByteBuffer的父类中有一个很重要的属性，此属性用于存储堆外内存的地址：

```java
// Used only by direct buffers 仅由直接缓冲区使用
// NOTE: hoisted here for speed in JNI GetDirectBufferAddress
long address;
```

我们操作堆外内存时通过unsafe类进行操作，并将内存地址直接传入提升JNI的GetDirectBufferAddress的速度。

下面我们来看一下DirectByteBuffer的使用，实际上因为继承了Buffer类，所以我们只要像操作普通Buffer那样即可操作DirectBuffer类。我们使用时，关于DirectBuffer主要有两类方法：

- putXXX：以putInt方法为例：源码如下：

  ![image-20221121112530961](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221121112530961.png)

- getXXX：以getInt方法为例：源码如下：

  ![image-20221121112742074](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20221121112742074.png)

### 3.2 DirectBuffer内存回收源码分析

DirectBuffer有两种内存回收方式，首先第一种是构造函数中调用Bits.reserveMemory方法进行内存回收。然后第二种是由虚引用进行被动回收。

上面学习了，`Bits.reserveMemory`方法会尝试完成本次堆外内存的创建，下面我们看一下此方法的源码

```java
static void reserveMemory(long size, int cap) {
	
    if (!memoryLimitSet && VM.isBooted()) {
        maxMemory = VM.maxDirectMemory();
        memoryLimitSet = true;
    }
	
    // optimist!
    //判断是否能分配内存
    if (tryReserveMemory(size, cap)) {
        return;
    }

    final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();

    // retry while helping enqueue pending Reference objects
    // which includes executing pending Cleaner(s) which includes
    // Cleaner(s) that free direct buffer memory
    //通过Reference#tryHandlePending进行一次清理
    while (jlra.tryHandlePendingReference()) {
        if (tryReserveMemory(size, cap)) {
            return;
        }
    }

    // trigger VM's Reference processing
    //尝试full gc清理直接内存
    System.gc();

    // a retry loop with exponential back-off delays
    // (this gives VM some time to do it's job)
    boolean interrupted = false;
    try {
        long sleepTime = 1;
        int sleeps = 0;
        while (true) {
            if (tryReserveMemory(size, cap)) {
                return;
            }
            //循环9次，一是为了重试循环，二是为了等一等，让JVM有时间尝试执行full gc
            if (sleeps >= MAX_SLEEPS) {
                break;
            }
            if (!jlra.tryHandlePendingReference()) {
                try {
                    Thread.sleep(sleepTime);
                    sleepTime <<= 1;
                    sleeps++;
                } catch (InterruptedException e) {
                    interrupted = true;
                }
            }
        }

        // no luck
        throw new OutOfMemoryError("Direct buffer memory");

    } finally {
        if (interrupted) {
            // don't swallow interrupts
            Thread.currentThread().interrupt();
        }
    }
}
```

此方法首先会调用tryReserveMemory尝试预留内存，我们先来看一下预留内存的tryReserveMemory方法，源码如下：

```java
private static boolean tryReserveMemory(long size, int cap) {

    // -XX:MaxDirectMemorySize limits the total capacity rather than the
    // actual memory usage, which will differ when buffers are page
    // aligned.
    long totalCap;
    //判断剩余内存是否足够完成此次内存分配
    while (cap <= maxMemory - (totalCap = totalCapacity.get())) {
        if (totalCapacity.compareAndSet(totalCap, totalCap + cap)) {
            //预留内存
            reservedMemory.addAndGet(size);
            count.incrementAndGet();
            return true;
        }
    }

    return false;
}
```

如果预留成功就退出，但是失败就会调用tryHandlePendingReference尝试清理，如果还不够分配那么就执行System.gc方法尝试执行full gc去清理内存，然后延迟重复执行此步骤九次，等待full gc，如果还不行那么就抛出oom。

然后我们看一下tryHandlePendingReference方法是怎么清理堆外内存的。tryHandlePendingReference方法源码如下，其实最终是调用java.lang.ref.Reference#tryHandlePending方法：

```java
static boolean tryHandlePending(boolean waitForNotify) {
    Reference<Object> r;
    Cleaner c;
    try {
        synchronized (lock) {
            if (pending != null) {
                r = pending;
                // 'instanceof' might throw OutOfMemoryError sometimes
                // so do this before un-linking 'r' from the 'pending' chain...
                //获取队列中的Cleaner对象
                c = r instanceof Cleaner ? (Cleaner) r : null;
                // unlink 'r' from 'pending' chain
                pending = r.discovered;
                r.discovered = null;
            } else {
                // The waiting on the lock may cause an OutOfMemoryError
                // because it may try to allocate exception objects.
                if (waitForNotify) {
                    lock.wait();
                }
                // retry if waited
                return waitForNotify;
            }
        }
    } catch (OutOfMemoryError x) {
        // Give other threads CPU time so they hopefully drop some live references
        // and GC reclaims some space.
        // Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above
        // persistently throws OOME for some time...
        Thread.yield();
        // retry
        return true;
    } catch (InterruptedException x) {
        // retry
        return true;
    }
	//调用Cleaner对象的clean方法进行清理
    // Fast path for cleaners
    if (c != null) {
        c.clean();
        return true;
    }

    ReferenceQueue<? super Object> q = r.queue;
    if (q != ReferenceQueue.NULL) q.enqueue(r);
    return true;
}
```

此方法其实主要就是获取pending队列中（虚引用的特性）的Cleaner对象，然后调用其clean方法清理堆外内存。那么这个Cleaner对象为什么能清理堆外内存呢？它又是从哪里来的呢？

> Cleaner类是继承了虚引用的，JVM在判断对象不可达之后，会将GC不可达的Cleaner对象放在pendingList中，所以在pendingList可以获取到Cleaner对象

我们进入Cleaner类，这个类继承了PhantomReference，说明他是一个虚引用的类。然后查看其clean方法：（[Cleaner类的openjdk地址](https://github.com/openjdk/jdk8/blob/master/jdk/src/share/classes/sun/misc/Cleaner.java)）：

~~~java
public class Cleaner
    extends PhantomReference<Object>
{
	//省略部分代码。。。

    private final Runnable thunk;

    private Cleaner(Object referent, Runnable thunk) {
        super(referent, dummyQueue);
        //构造函数
        this.thunk = thunk;
    }

    /**
     * Creates a new cleaner.
     *
     * @param  ob the referent object to be cleaned
     * @param  thunk
     *         The cleanup code to be run when the cleaner is invoked.  The
     *         cleanup code is run directly from the reference-handler thread,
     *         so it should be as simple and straightforward as possible.
     *
     * @return  The new cleaner
     */
    public static Cleaner create(Object ob, Runnable thunk) {
        if (thunk == null)
            return null;
        return add(new Cleaner(ob, thunk));
    }

    /**
     * Runs this cleaner, if it has not been run before.
     */
    public void clean() {
        if (!remove(this))
            return;
        try {
            thunk.run();
        } catch (final Throwable x) {
            AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        if (System.err != null)
                            new Error("Cleaner terminated abnormally", x)
                                .printStackTrace();
                        System.exit(1);
                        return null;
                    }});
        }
    }

}
~~~

clean方法会调用内部Field即thunk的run方法。也就是说真正执行清理的是run方法，这个属性是构造函数传入的。那么Cleaner是什么时候创建的呢？run方法中又是怎么清理的呢？我们在3.1中DirectBuffer的构造函数中学习了，这里会调用Cleaner的create方法创建Cleaner对象（代码如下）

~~~java
cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
~~~

而Cleaner的create方法就会真正调用构造函数创建Cleaner对象。也就是说create方法传入的Deallocator就是thunk这个Runnable属性的本体。我们看一下Deallocator的源码：

```java
private static class Deallocator
    implements Runnable
{

    private static Unsafe unsafe = Unsafe.getUnsafe();

   //省略部分代码

    public void run() {
        if (address == 0) {
            // Paranoia
            return;
        }
        unsafe.freeMemory(address);
        address = 0;
        Bits.unreserveMemory(size, capacity);
    }

}
```

我们重点关注run方法，我们可以看到，这里最终是调用unsafe类去完成堆外内存的释放。

到此为止，我们介绍了DirectBuffer的第一种内存回收方法，即主动调用`tryHandlePendingReference方法`去释放内存。

然后我们在构建Cleaner对象时，因为Cleaner对象继承了Reference类，所以我们看一下这个类的静态代码块：

```java
//Reference类的静态代码块：
static {
    ThreadGroup tg = Thread.currentThread().getThreadGroup();
    for (ThreadGroup tgn = tg;
         tgn != null;
         tg = tgn, tgn = tg.getParent());
    Thread handler = new ReferenceHandler(tg, "Reference Handler");
    /* If there were a special system-only priority greater than
     * MAX_PRIORITY, it would be used here
     */
    handler.setPriority(Thread.MAX_PRIORITY);
    handler.setDaemon(true);
    handler.start();

    // provide access in SharedSecrets
    SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
        @Override
        public boolean tryHandlePendingReference() {
            return tryHandlePending(false);
        }
    });
}
```

在静态代码块里创建了一个ReferenceHandler后台线程，我们看一下这个线程：

```java
private static class ReferenceHandler extends Thread {

    private static void ensureClassInitialized(Class<?> clazz) {
        try {
            Class.forName(clazz.getName(), true, clazz.getClassLoader());
        } catch (ClassNotFoundException e) {
            throw (Error) new NoClassDefFoundError(e.getMessage()).initCause(e);
        }
    }

    static {
        // pre-load and initialize InterruptedException and Cleaner classes
        // so that we don't get into trouble later in the run loop if there's
        // memory shortage while loading/initializing them lazily.
        ensureClassInitialized(InterruptedException.class);
        ensureClassInitialized(Cleaner.class);
    }

    ReferenceHandler(ThreadGroup g, String name) {
        super(g, name);
    }

    public void run() {
        while (true) {
            tryHandlePending(true);
        }
    }
}
```

我们可以看到这个后台线程会不断执行tryHandlePending方法，此方法我们上面已经学习过了，他会取出cleaner对象并执行clean方法释放内存。以上就是DirectBuffer的内存的被动回收，或者也可以叫做后台回收。

### 3.3 DirectBuffer内存泄露问题

使用直接内存有时会发生这种问题，那就是堆内存还剩很多，但是直接内存却没剩多少。从DirectBuffer内存回收的角度看，发生这种问题主要有以下几种原因：

- 可能通过JVM参数DIsableExplicitGC禁用了System.gc方法，导致tryHandlePending主动回收内存时的full gc无效
- DirectBuffer的生命周期较长，大量的DirectBuffer移动到了老年代，老年代的GC没有新生代频繁。
- 堆内存很大，老年代也很大，一直没有机会去full gc，导致老年代的DirectBuffer没有被清理的机会
- 不断创建DirectBuffer对象，在Java堆中对象很小，但是其直接内存中的数据很大，导致直接内存被耗光。

### 3.4 DirectBuffer的配置和问题

我们可以通过-XX:MaxDirectMemorySize1配置JVM的直接内存，默认情况加该值与堆内存一致。但是使用此参数时要注意，只有Java自带的` ByteBuffer.allocateDirect(size) `或者直接 `new DirectByteBuffer(capacity) `才生效，如果你自己通过反射获取unsafe类，那么此JVM参数无效，原因其实就是在tryReserveMemory方法中进行了判断和管理。具体的例子可以见我的[JVM笔记1.3.4直接内存溢出](https://github.com/Loserfromlazy/Code_Career/blob/master/java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87%E4%B8%80%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md#134-%E6%9C%AC%E6%9C%BA%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA)

其次，如果我们在项目中使用了DirectBuffer，那么最好不要使用`-XX:+DisableExplicitGC`参数进行优化。

正常情况下，我们使用`-XX:+DisableExplicitGC`进行优化时是因为System.gc会直接触发full gc，一般情况下，频繁的触发垃圾回收是会影响系统性能的，因此垃圾回收应该是自动进行的，所以JVM会提供此参数进行控制。但如果我们使用直接内存，那么就会使System.gc失效，导致主动释放直接内存时System.gc成为空方法，因此如果我们在项目中使用了DirectBuffer，那么最好不要使用`-XX:+DisableExplicitGC`参数进行优化。

## 四 、mmap的使用和原理

4.1 mmap基本使用

4.2 mmap的使用示例

4.3 mmap的核心原理

4.4 mmap+write进行文件传输实例

