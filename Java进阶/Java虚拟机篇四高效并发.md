# Java虚拟机篇四高效并发

**禁止转载！！**

> 本篇是Java虚拟机的学习笔记的第四篇，高效并发
>
> 参考资料：深入理解Java虚拟机周志明第三版以及互联网资源具体引用会在文中标注
>
> 本文大部分都是从《深入理解Java虚拟机周志明第三版》进行拷贝和引用的，目的是为了学习一遍并加深印象，同时整理重要知识点方便日后进行复习。

# 一、Java内存模型与线程

## 1.1 概述

多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。在许多场景下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘I/O、网络通信或者数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的空闲状态，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的性能浪费，而让计算机同时处理几项任务则是最容易想到，也被证明是非常有效的“压榨”手段。

除了充分利用计算机处理器的能力外，一个服务端要同时对多个客户端提供服务，则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数 (TransactionsPer Second，TPS)是重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高:反之，线程之间频繁争用数据，互相阻塞甚至死锁，将会大大降低程序的并发能力。

## 1.2 硬件效率与一致性

绝大多数的运算任务都不可能只靠处理器计算就能完成。处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个 I/O 操作很难消除(无法仅靠寄存器来完成所有运算任务)。由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存(Cache) 来作为内存与处理器之间的缓冲，也就是将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也带来了更高的复杂度，它引入了一个新的问题：缓存一致性 (Cache Coherence)。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)，这种系统称为共享内存多核系统(Shared Memory Multiprocessors System)，如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230424172108912](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424172108912.png)

为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 `MSI、MESI、MOSI、Synapse、Firefly Dragon Protocol等` 。

除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Order Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有指令重排序(Instruction Reorder)优化。

## 1.3 Java内存模型

《Java 虚拟机规范》中曾试图定义一种Java 内存模型(Java Memory Model.JMM)来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言 (如 C和C++ 等) 直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，所以在某些场景下必须针对不同的平台来编写程序。经过长时间的验证和修补，直至JDK 5(实现了JSR-133)发布后，Java内存模型才终于成熟、完善起来了。

### 1.3.1 主内存与工作内存

Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量 (Variables)与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得更好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施。

Java 内存模型规定了所有的变量都存储在主内存(Main Memory)中(此处的主内存与物理硬件的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的部分)。每条线程还有自己的工作内存(Working Memory，可与处理器高速缓存类比)，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230424173947453](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424173947453.png)

这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区并不是同一层次的概念，两者基本没有任何关系。

### 1.3.2 内存间交互操作

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存的这种实现细节，在Java中一共定义了以下8种操作来完成，Java虚拟机必须保证下面的每一种操作都是原子的、不可再分的：

- lock：作用于主内存的变量，把每一个变量标识为一条线程独占的状态。
- unlock

### 对于volatile的特殊规则

### 针对long和double变量的特殊规则

### 原子性、可见性和有序性

### 先行发生原则

## 1.4 Java与线程

线程的实现

Java线程调度

状态转换

## 1.5 Java与协程

内核线程的局限

协程的复苏

Java的解决方案

# 二、线程安全与锁优化

## 2.1 概述

## 2.2 线程安全

## 2.3 锁优化
