# Java虚拟机篇四高效并发

**禁止转载！！**

> 本篇是Java虚拟机的学习笔记的第四篇，高效并发
>
> 参考资料：深入理解Java虚拟机周志明第三版以及互联网资源具体引用会在文中标注
>
> 本文大部分都是从《深入理解Java虚拟机周志明第三版》进行拷贝和引用的，目的是为了学习一遍并加深印象，同时整理重要知识点方便日后进行复习。

# 一、Java内存模型与线程

## 1.1 概述

多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。在许多场景下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘I/O、网络通信或者数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的空闲状态，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的性能浪费，而让计算机同时处理几项任务则是最容易想到，也被证明是非常有效的“压榨”手段。

除了充分利用计算机处理器的能力外，一个服务端要同时对多个客户端提供服务，则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数 (TransactionsPer Second，TPS)是重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高:反之，线程之间频繁争用数据，互相阻塞甚至死锁，将会大大降低程序的并发能力。

## 1.2 硬件效率与一致性

绝大多数的运算任务都不可能只靠处理器计算就能完成。处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个 I/O 操作很难消除(无法仅靠寄存器来完成所有运算任务)。由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存(Cache) 来作为内存与处理器之间的缓冲，也就是将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也带来了更高的复杂度，它引入了一个新的问题：缓存一致性 (Cache Coherence)。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)，这种系统称为共享内存多核系统(Shared Memory Multiprocessors System)，如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230424172108912](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424172108912.png)

为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 `MSI、MESI、MOSI、Synapse、Firefly Dragon Protocol等` 。

除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Order Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有指令重排序(Instruction Reorder)优化。

## 1.3 Java内存模型

《Java 虚拟机规范》中曾试图定义一种Java 内存模型(Java Memory Model.JMM)来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言 (如 C和C++ 等) 直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，所以在某些场景下必须针对不同的平台来编写程序。经过长时间的验证和修补，直至JDK 5(实现了JSR-133)发布后，Java内存模型才终于成熟、完善起来了。

### 1.3.1 主内存与工作内存

Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量 (Variables)与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得更好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施。

Java 内存模型规定了所有的变量都存储在主内存(Main Memory)中(此处的主内存与物理硬件的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的部分)。每条线程还有自己的工作内存(Working Memory，可与处理器高速缓存类比)，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230424173947453](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424173947453.png)

这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区并不是同一层次的概念，两者基本没有任何关系。

### 1.3.2 内存间交互操作

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存的这种实现细节，在Java中一共定义了以下8种操作来完成，Java虚拟机必须保证下面的每一种操作都是原子的、不可再分的：

- lock：作用于主内存的变量，把每一个变量标识为一条线程独占的状态。
- unlock：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他变量锁定。
- read：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便于load动作使用。
- load：作用于工作内存的变量，把read操作从主内存得到的变量值放入到工作内存的变量副本中。
- use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。
- write：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load，如果要把变量从工作内存同步到主内存，那就要按顺序执行store和write操作。注意，Java内存模型只要求这两个操作按顺序执行，但不要求是连续执行。Java内存模型还规定了在执行上面八种基本操作时满足以下规则：

- 不允许read 和load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地 (没有发生过任何 assign 操作)把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load 或assign)的变量，换句话说就是对一个变量实施 use、store 操作之前，必须先执行assign 和load 操作。
- 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
- 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或assign 操作以初始化变量的值。
- 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock一个被其他线程锁定的变量。
- 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)。

这八种内存访问操作和上面的规则，再加上volatile的特殊规定，就能准确的描述出Java程序中哪些内存访问操作在并发下是安全的。

### 1.3.3 对于volatile的特殊规则

关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制，但是它并不容易被正确、完整地理解。Java 内存模型为 volatile 专门定义了一些特殊的访问规则，当一个变量被定义成 volatile 之后，它将具备两项特性：

- 第一项是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程 A 修改一个普通变量的值，然后向主内存进行回写。另外一条线程 B 在线程A 回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。

  注意，虽然volatile 变量对所有线程是立即可见的，对 volatile 变量所有的写操作都能立刻反映到其他线程之中，但是这并不能说明volatile变量在并发下是线程安全的。volatile 变量在各个线程的工作内存中是不存在一致性问题的 (从物理存储的角度看，各个线程的工作内存中 volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题)，但是 Java 里面的运算操作符并非原子操作，这导致 volatile 变量的运算在并发下一样是不安全的。

  我们举个例子（下面的例子来自我之前的笔记，当然与原书《深入理解Java虚拟机周志明第三版》的例子是一类的）：

  ```java
  public class TestPlusPlus {
      int sum = 0;
      public void increase(){
          sum++;
      }
  }
  ```

  我们用javap工具查看该类的反编译

  ![image-20220424143930948](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220424143930948.png)

  从图中我们可以看到一个`sum++`操作主要有四步：

  首先`getfield`表示获取当前sum变量的值，并且放入栈顶。然后`iconst_1`表示将常量1放入栈顶。再然后`iadd`表示将当前栈顶的两个值相加，并且将结果放入栈顶。最后`putfield`表示将栈顶的结果再赋值给sum变量。

  由于volatile只能保证可见性，所以如果以下两个规则不满足，我们还是需要加锁来保证原子性：

  - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
  - 变量不需要与其他的状态变量共同参与不变约束。

- 使用 volatile 变量的第二个语义是禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。但是在同一个线程的方法执行过程中无法感知到这点，因为在Java 内存模型中描述了“线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)。As-if-Serial规则的具体内容为：无论如何重排序，都必须保证代码在单线程下运行正确。

被volatile修饰的变量，如果我们查看其汇编代码，会发现在赋值后会多执行了一个`lock addl $0x0,(%esp)`操作，这个操作的作用是相当于一个内存屏障，指令重排序时不能把后面的指令重排序到内存屏障之前的位置。

> 关于内存屏障可以去看我的学习笔记《Java高并发编程篇三CAS原子类以及有序性和可见性》这里就不贴链接了。

上面的`lock addl $0x0,(%esp)`中的`addl $0x0,(%esp)`是把ESP寄存器的值加0，也就是一个空操作，之所以使用空操作而不是空操作专用指令nop，是因为IA32手册规定lock不允许配合nop指令使用。这里的这个lock前缀的作用是将本处理器的缓存写入内存，写入动作会造成别的处理器或别的内核无效化缓存，所以这个空操作可以让volatile变量的修改对其他处理器立即可见。

在某些情况下，volatile 的同步机制的性能确实要优于锁(使用 synchronized 关键字或java.util.concurrent 包里面的锁)，但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说 volatile 就会比 synchronized快上多少。如果让 volatile 自己与自已比较，那可以确定一个原则:volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

最后通过Java内存模型中对volatile变量定义的特殊规则进行总结，假定T表示一个线程，V和W分别表示两个 volatile 型变量，那么在进行 read、loaduse、assign、store和 write 操作时需要满足如下规则:

- 只有当线程T对变量 V执行的前一个动作是 load 的时候，线程T才能对变量 V执行 use 动作；并且，只有当线程T对变量 V执行的后一个动作是 use 的时候，线程T才能对变量 V执行 load 动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read 动作相关联的，必须连续且一起出现。

  **就是说要求在工作内存中，每次使用 V 前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量 V 所做的修改**

- 只有当线程T对变量 V执行的前一个动作是 assign 的时候，线程T才能对变量 V执行 store 动作；并且只有当线程 T 对变量 V 执行的后一个动作是 store 的时候，线程T才能对变量 V 执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write 动作相关联的，必须连续且一起出现。

  **就是说要求在工作内存中，每次修改 V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量 V 所做的修改**

- 假定动作A是线程T对变量V实施的 use 或 assign 动作，假定动作F是和动作A相关联的 load 或 store 动作，假定动作 P 是和动作 F 相应的对变量 V 的read 或 write动作；与此类似，假定动作B是线程T对变量W实施的use 或assign动作假定动作G是和动作 B相关联的 load 或store 动作，假定动作Q是和动作G相应的对变量W的read或write 动作。如果A先于B，那么P先于Q。

  **也就是要求 volatile 修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。**

### 1.3.4 针对long和double变量的特殊规则

Java内存模型要求 lock、unlock、read、load、assign、use、store、write 这八种操作都具有原子性，但是对于64 位的数据类型 (long 和double)，在模型中特别定义了一条宽松的规定:允许虚拟机将没有被 volatile 修饰的64 位数据的读写操作划分为两次 32位的操作来进行，即允许虚拟机实现自行选择是否要保证 64 位数据类型的 load、store、read 和write 这四个操作的原子性，这就是所谓的“long 和double 的非原子性协定”(Non-AtomicTreatment of double and long Variables)。

如果有多个线程共享一个并未声明为 volatile 的 long 或 double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了“半个变量”的数值。当然这种情况极其罕见，在目前主流平台下商用的 64 位 Java 虚拟机中并不会出现非原子性访问行为，但是对于32位的Java 虚拟机，譬如比较常用的 32 位x86 平台下的 HotSpot 虚拟机对 long类型的数据确实存在非原子性访问的风险。从JDK 9起，HotSpot 增加了一个实验性的参数-XX:+AlwaysAtomicAccesses (这是JEP 188 对Java 内存模型更新的一部分内容)来约束虚拟机对所有数据类型进行原子性的访问。而针对 double 类型，由于现代中央处理器中一般都包含专门用于处理浮点数据的浮点运算器(Floating Point Unit，FPU)，用来专门处理单、双精度的浮点数据，所以哪怕是 32 位虚拟机中通常也不会出现非原子性访问的问题。在实际开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码时一般不需要因为这个原因刻意把用到的 long 和 double变量专门声明为 volatile。

### 1.3.5 原子性、可见性和有序性

**原子性**

由Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和write 这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的 (例外就是 long 和 double 的非原子性协定）。

如果应用场景需要一个更大范围的原子性保证，Java 内存模型还提供了lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter和 monitorexit来隐式地使用这两个操作。这两个字节码指令反映到 Java 代码中就是同步块 synchronized 关键字，因此在synchronized 块之间的操作也具备原子性。

**可见性**

可见性就是当一个线程修改了共享变量的值时，其他线程能立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此。普通变量与 volatile变量的区别是，volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此可以说 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

除了 volatile 之外，Java 还有两个关键字能实现可见性，它们是 synchronized 和 final。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)”这条规则获得的。而final关键字的可见性是指:被 final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去，那么在其他线程中就能看见 final 字段的值。

> this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象。关于this引用逃逸，我是通过这篇文章进行学习的[Java 引用逃逸那些事](https://cloud.tencent.com/developer/article/1509584),下面是部分原文：
>
> Java 分配在堆上的对象都是靠引用来操作的,当对象在某个方法中都定义之后, 把它的引用作为其他方法的参数传递过去, 这样就叫做对象的引用逃逸,而如果原本对象在当前方法结束后就会被垃圾回收器标记和回收,但由于其引用被传递出去,当被一个长期存活的对象所持有时,那原来的对象的生命周期就变成跟这个长期存在于堆内存的对象一样, 对于这样一些临时对象没有做到即时的回收,就会造成JVM的内存占用, 严重情况更会是触发Full GC,从而影响程序性能.
>
> **this 引用逃逸**  在构造函数返回之前, 其他线程就通过this引用访问到了"未完成初始化"的对象, 而调用尚未构造完全的对象就会不可预知的问题, 因此this 引用逃逸引发的问题是线程安全问题.
>
> 主要发生场景是在构造函数启动线程,或者注册监听时发生,如下代码:
>
> ```java
>   public class UnsafeThisEscape {
>       private String id;
>       
>       public ThisEscape(String id) {
>           new Thread(new EscapeRunnable()).start();
>           // ...其他代码
>           this.id = id;
>       }
>       
>       private class EscapeRunnable implements Runnable {
>           @Override
>           public void run() {
>               System.out.println("id: "+UnsafeThisEscape.this.id);  
>               // 在这里通过UnsafeThisEscape.this就可以引用UnsafeThisEscape对象, 但是此时UnsafeThisEscape对象可能还没有构造完成, 即发生了this引用的逃逸.
>           }
>       }
>   }
> ```
>
> 想要避免 this 引用逃逸,那当然就是不要在构造器中执行其他线程与当前引用对象相关的操作, 构造器仅用来完成初始化操作, 在上面的场景中处理方式就是在构造函数中创建线程，但不启动它。在构造函数外面再启动,可以专门提供一个方法出来,调整后如下所示:
>
> ```java
>   public class SafeThisEscape {
>       private Thread t;
>       private String id;
>   
>       public ThisEscape(String id) {
>           t = new Thread(new EscapeRunnable());
>           this.id = id;
>           // ...其他代码
>       }
>       
>       public void init() {
>           t.start();
>       }   
>       private class EscapeRunnable implements Runnable {
>           @Override
>           public void run() {
>               System.out.println("id: "+UnsafeThisEscape.this.id);  
>               // 这里通过SafeThisEscape.this引用的对象,是已经构造完成的,保证了线程安全.
>           }
>       }
>   }
> ```

**有序性**

Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的;如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”(Within-Thread As-If-Serial Semantics)，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

Java语言提供了 volatile和synchronized 两个关键字来保证线程之间操作的有序性volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

### 1.3.6 先行发生原则

如果Java内存模型中所有的有序性都仅靠 volatile和synchronized 来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写 Java 并发代码的时候并没有察觉到这一点，这是因为 Java 语言中有一个“先行发生”( Happens-Before)的原则。JMM定义了一套自己的规则：Happens-Before（先行发生）规则，并且确保只要两个Java语句之间必须存在Happens-Before关系，JMM尽量确保这两个Java语句之间的内存可见性和指令有序性。这个原则非常重要它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入 Java 内存模型苦涩难懂的定义之中。

先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，比如说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前操作 A 产生的影响能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

## 1.4 Java与线程

线程的实现

Java线程调度

状态转换

## 1.5 Java与协程

内核线程的局限

协程的复苏

Java的解决方案

# 二、线程安全与锁优化

## 2.1 概述

## 2.2 线程安全

## 2.3 锁优化
