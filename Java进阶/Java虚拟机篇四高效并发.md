# Java虚拟机篇四高效并发

**禁止转载！！**

> 本篇是Java虚拟机的学习笔记的第四篇，高效并发
>
> 参考资料：深入理解Java虚拟机周志明第三版以及互联网资源具体引用会在文中标注
>
> 本文大部分都是从《深入理解Java虚拟机周志明第三版》进行拷贝和引用的，目的是为了学习一遍并加深印象，同时整理重要知识点方便日后进行复习。

# 一、Java内存模型与线程

## 1.1 概述

多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。在许多场景下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘I/O、网络通信或者数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的空闲状态，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的性能浪费，而让计算机同时处理几项任务则是最容易想到，也被证明是非常有效的“压榨”手段。

除了充分利用计算机处理器的能力外，一个服务端要同时对多个客户端提供服务，则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数 (TransactionsPer Second，TPS)是重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高:反之，线程之间频繁争用数据，互相阻塞甚至死锁，将会大大降低程序的并发能力。

## 1.2 硬件效率与一致性

绝大多数的运算任务都不可能只靠处理器计算就能完成。处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个 I/O 操作很难消除(无法仅靠寄存器来完成所有运算任务)。由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存(Cache) 来作为内存与处理器之间的缓冲，也就是将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也带来了更高的复杂度，它引入了一个新的问题：缓存一致性 (Cache Coherence)。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)，这种系统称为共享内存多核系统(Shared Memory Multiprocessors System)，如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230424172108912](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424172108912.png)

为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 `MSI、MESI、MOSI、Synapse、Firefly Dragon Protocol等` 。

除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Order Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有指令重排序(Instruction Reorder)优化。

## 1.3 Java内存模型

《Java 虚拟机规范》中曾试图定义一种Java 内存模型(Java Memory Model.JMM)来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言 (如 C和C++ 等) 直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，所以在某些场景下必须针对不同的平台来编写程序。经过长时间的验证和修补，直至JDK 5(实现了JSR-133)发布后，Java内存模型才终于成熟、完善起来了。

### 1.3.1 主内存与工作内存

Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量 (Variables)与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得更好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施。

Java 内存模型规定了所有的变量都存储在主内存(Main Memory)中(此处的主内存与物理硬件的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的部分)。每条线程还有自己的工作内存(Working Memory，可与处理器高速缓存类比)，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图（图片来自《深入理解Java虚拟机周志明第三版》）：

![image-20230424173947453](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424173947453.png)

这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区并不是同一层次的概念，两者基本没有任何关系。

### 1.3.2 内存间交互操作

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存的这种实现细节，在Java中一共定义了以下8种操作来完成，Java虚拟机必须保证下面的每一种操作都是原子的、不可再分的：

- lock：作用于主内存的变量，把每一个变量标识为一条线程独占的状态。
- unlock：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他变量锁定。
- read：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便于load动作使用。
- load：作用于工作内存的变量，把read操作从主内存得到的变量值放入到工作内存的变量副本中。
- use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。
- write：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load，如果要把变量从工作内存同步到主内存，那就要按顺序执行store和write操作。注意，Java内存模型只要求这两个操作按顺序执行，但不要求是连续执行。Java内存模型还规定了在执行上面八种基本操作时满足以下规则：

- 不允许read 和load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地 (没有发生过任何 assign 操作)把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load 或assign)的变量，换句话说就是对一个变量实施 use、store 操作之前，必须先执行assign 和load 操作。
- 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
- 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或assign 操作以初始化变量的值。
- 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock一个被其他线程锁定的变量。
- 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)。

这八种内存访问操作和上面的规则，再加上volatile的特殊规定，就能准确的描述出Java程序中哪些内存访问操作在并发下是安全的。

### 1.3.3 对于volatile的特殊规则

关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制，但是它并不容易被正确、完整地理解。Java 内存模型为 volatile 专门定义了一些特殊的访问规则，当一个变量被定义成 volatile 之后，它将具备两项特性：

- 第一项是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程 A 修改一个普通变量的值，然后向主内存进行回写。另外一条线程 B 在线程A 回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。

  注意，虽然volatile 变量对所有线程是立即可见的，对 volatile 变量所有的写操作都能立刻反映到其他线程之中，但是这并不能说明volatile变量在并发下是线程安全的。volatile 变量在各个线程的工作内存中是不存在一致性问题的 (从物理存储的角度看，各个线程的工作内存中 volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题)，但是 Java 里面的运算操作符并非原子操作，这导致 volatile 变量的运算在并发下一样是不安全的。

  由于volatile只能保证可见性，所以如果以下两个规则不满足，我们还是需要加锁来保证原子性：

  - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
  - 变量不需要与其他的状态变量共同参与不变约束。

- 使用 volatile 变量的第二个语义是禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是 Java 内存模型中描述的所谓“线程内表现为串行的语义”(Within-Thread As-IfSerial Semantics)。我们举个例子：

eof

### 针对long和double变量的特殊规则

### 原子性、可见性和有序性

### 先行发生原则

## 1.4 Java与线程

线程的实现

Java线程调度

状态转换

## 1.5 Java与协程

内核线程的局限

协程的复苏

Java的解决方案

# 二、线程安全与锁优化

## 2.1 概述

## 2.2 线程安全

## 2.3 锁优化
