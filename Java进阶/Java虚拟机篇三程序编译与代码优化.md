# Java虚拟机篇三程序编译与代码优化

**禁止转载！！**

> 本篇是Java虚拟机的学习笔记的第三篇，程序编译与代码优化。
>
> 参考资料：深入理解Java虚拟机周志明第三版以及互联网资源具体引用会在文中标注
>
> 本文大部分都是从《深入理解Java虚拟机周志明第三版》进行拷贝和引用的，目的是为了学习一遍并加深印象，同时整理重要知识点方便日后进行复习。

# 一、前端编译与优化

## 1.1 概述

在Java技术下谈编译期而没有上下文的话是很含糊的表达，因为这可能指一个前端编译器把`*.java`转换成`*.class`文件的过程；也可能是指Java虚拟机的即时编译器，运行时把字节码转换成本地机器码的过程；也可能是使用静态的提前编译器，直接把程序编译成与目标机器指令集相关的二进制代码的过程，下面是代表性产品：

- 前端编译器：javac，Eclipse JDT的ECJ增量式编译器
- 即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器
- 提前编译器：JDK的Jaotc，GNU Compiler for the Java（GCJ），Excelsior JET

一般来说Java虚拟机的设计团队选择把性能优化集中到运行期的即时编译器中，这样不仅可以让Javac产生的class文件，还可以让其它语言的如Groovy的class文件也同样享受到编译器优化带来的性能红利。 

如果把开发阶段的优化也计算进来的话，Javac 确实是做了许多针对 Java 语言编码过程的优化措施来降低程序员的编码复杂度、提高编码效率。相当多新生的 Java 语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者 Java 拟机的底层改进来支持。也就是说Java 中即时编译器在运行期的优化过程，支撑了程序执行效率的不断提升:而前端编译器在编译期的优化过程，则是支撑着程序员的编码效率和语言使用者的幸福感的提高。

## 1.2 Javac编译器

### 1.2.1 导入Javac源码

在JDK 6发布时通过了JSR 199 编译器API的提案，使得 Javac 编译器的实现代码晋升成为标准 Java 类库之一，它的源码就改为放在`JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac` 中。到了JDK9时，整个JDK 所有的 Java 类库都采用模块化进行重构划分，Javac 编译器就被挪到`jdk.compiler`模块(路径为:`JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac`)里面。

我们这里使用jdk8的版本，所以首先可以去下载openjdk的langtools的源码[openjdk-langtools下载地址](https://hg.openjdk.org/jdk8/jdk8/langtools/)。在这个网址里只需要点击zip就可以下载zip包了。然后新建一个空的Java项目，在src下手动建立com文件下，并在com文件夹下手动建立sun文件夹。注意一定要手动创建，不然IDEA会修改某些类的路径。

![image-20230424113820759](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424113820759.png)

然后将下载的源码的`src/share/classes/com/sun/*`路径下的所有代码拷贝到我们手动建的文件夹下，然后运行Main函数见到下面的输出，则Javac源码就完成了导入：

![image-20230424114055183](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424114055183.png)

如果想编译Java文件的话，只需要在main的启动参数上配置要编译的类的路径即可，如下图：

![image-20230424115056822](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424115056822.png)

### 1.2.2 Javac编译流程

Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3 个处理过程：

1. 准备过程：初始化插入式注解处理器
2. 解析与填充符号表过程：
   - 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。
   - 填充符号表。产生符号地址和符号信息。
3. 插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段
4. 分析与字节码生成过程
   - 标注检查。对语法的静态信息进行检查。
   - 数据流及控制流分析。对程序动态运行过程进行检查。
   - 解语法糖。将简化代码编写的语法糖还原为原有的形式。
   - 字节码生成。

上面的2、3、4步的关系如下（图片来自《深入理解Java虚拟机第三版》）：

![image-20230518161012500](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230518161012500.png)

代码流程如下图：

![image-20230424133853050](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424133853050.png)

#### 解析与填充符号表

我们从第二步解析与填充符号表过程开始看，这个过程包含了经典编译原理的词法分析和语法分析两个步骤：

- 首先是词法分析，它是将源代码的字符流转变为标记 (Token)集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记，如`int a = b+2`这句代码中就包含了6个标记，分别是 `int、a、=、b、+、2`，虽然关键字int由3 个字符构成，但是它只是一个独立的标记，不可以再拆分。在 Javac 的源码中，词法分析过程由 com.sun.tools.javac.parser.Scanner类来实现。
- 语法分析是根据标记序列构造抽象语法树的过程，抽象语法树(Abstract Syntax Tree，AST)是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。在 Javac 的源码中，语法分析过程由 `com.sun.tools.javac.parser.Parser`类实现，这个阶段产出的抽象语法树是以`com.sun.tools.javac.tree.JCTree` 类表示的。

生成语法树以后，编译器就不会再对源码字符流进行操作了，后续的操作都建立在抽象语法树之上。

完成了语法分析和词法分析之后，下一个阶段是对符号表进行填充的过程，也就是`enterTrees`方法要做的事情。符号表是由一组符号地址和符号信息构成的数据结构，可以简单理解为哈希表中键值对的存储形式(实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表栈结构符号表等各种形式)。符号表中所登记的信息在编译的不同阶段都要被用到。比如在语义分析的过程中，符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的声明是否一致)和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。在Javac 源代码中，填充符号表的过程由 `com.sun.tools.javac.comp.Enter` 类实现，该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，以及`package-info.java` (如果存在的话)的顶级节点。

#### 注解处理器

JDK5以后，Java语言提供了对注解的支持，注解在设置上原本与普通代码一样，都只在程序运行期间发挥作用，但在JDK6中又提出并通过了JSR-269提案，该提案设计了一组插入式注解处理器的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。可以把插入式注解处理器看作是一组编译器插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次(Round)。（流程可以对应上图）

有了编译器注解处理的标准 API后，程序员的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件中被访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。比如 Java 著名的编码效率工具Lombok，它可以通过注解来实现自动产生 getter/setter 方法、进行空置检查、生成受查异常表、产生 equals()和 hashCode()方法等等。

#### 语义分析与字节码生成

经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义逻辑是符合逻辑的。而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查，比如进行类型检查、控制流检查、数据流检查等。举个例子，比如下面的代码：

~~~java
int a = 1;
boolean b = false;
char c = 2;
~~~

后续可能出现相关的赋值运算：

~~~java
int d = a + c;
int d = b + c;
char d = a + c;
~~~

这三个操作只有一是没有错误的，其余在Java语言中是不合逻辑的，无法进行编译。我们编码是在IDE看到的由红线标注的错误提示，绝大部分都是来源于语义分析阶段的检查结果。

**标注检查**

Javac在编译过程中，语义分析过程可以分为标注检查和控制流分析两部分，分别由`attribute`和`flow`方法完成。

标注检查步骤要检查的内容包括变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。上面的赋值例子就属于标注检查的范围。在标注检查的过程中，还会顺便进行一个常量折叠的代码优化，这时Javac编译器会对源代码做的极少量耳带优化措施之一（代码优化几乎都在即时编译器进行）。举个例子，假如有变量定义`int a = 1 + 2`在抽象语法树上仍能看到字面量`1`，`2`和操作符`+`号。但是在经过常量折叠的优化之后，他们会被折叠为字面量3。由于由于编译期间进行了常量折叠，所以在代码里面定义`a=1+2`比起直接定义`a=3`来，并不会增加程序运行期哪怕仅仅一个处理器时钟周期的处理工作量。标注检查步骤在Javac源码中的实现类是`com.sun.tools.javac.comp.Attr` 类和 `com.sun.tools.javac.comp.Check` 类。

**数据及控制流分析**

数据及控制流分析是对程序上下文逻辑更进一步的验证，他可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路是否有返回值，是否所有的受检异常都被正确的处理了等问题。编译时期的数据及控制流分析与类加载时期的数据及控制流分析的目的基本上是一致的，但是校验范围会有区别，有一些校验只有在编译或运行期才能进行。举个例子：

```java
public void foo(final int arg){
    final int var = 0;
    //...
}

public void foo1(int arg){
    int var = 0;
    //...
}
```

这两个方法的字节码如下：

~~~
//foo方法字节码
public void foo(int);
descriptor: (I)V
flags: ACC_PUBLIC
Code:
  stack=0, locals=3, args_size=2
     0: return
  LineNumberTable:
    line 15: 0
//foo1方法字节码
public void foo1(int);
descriptor: (I)V
flags: ACC_PUBLIC
Code:
  stack=1, locals=3, args_size=2
     0: iconst_0
     1: istore_2
     2: return
  LineNumberTable:
    line 13: 0
    line 15: 2
~~~

> 上面的foo方法（foo1同理）字节码的含义如下：
>
> - `stack=0`：操作数栈的深度为0，表示没有需要使用的操作数栈空间。
> - `locals=3`：本地变量表的大小为3，表示方法内部使用了3个本地变量槽位。
> - `args_size=2`：方法参数的大小为2，表示方法有两个参数（注意方法默认会包括隐式的 `this` 参数，所以是两个参数）。
> - `0: return`：该方法的唯一指令是 `return`，用于从当前方法返回。
> - `LineNumberTable`：行号表指示字节码指令与源代码行号之间的映射关系，这里表示字节码指令0与源代码的第15行对应。
>
> 注意：在 Java 中，使用 `final` 修饰的局部变量会被认为是常量，编译器会对它们进行优化。对于 `final` 修饰的局部变量，编译器会将其存储在常量池中，并在需要时直接从常量池中加载，而不是从操作数栈中加载。
>
> 因此，当使用 `final` 修饰的变量时，字节码指令会直接从常量池中加载变量的值，而不需要使用操作数栈。这就是为什么在两段字节码中foo方法并没有使用操作数栈的原因。
>
> 总结就是当变量被 `final` 修饰时，编译器会对其进行优化，将其存储在常量池中，并直接从常量池加载其值，而不需要使用操作数栈。这可以减少对操作数栈的使用，从而减少字节码的大小。
>
> 在Java字节码中，对于方法的参数和局部变量，编译器会生成特定的指令来加载和存储这些变量。对于使用了`final`修饰的参数或局部变量，编译器会生成额外的指令来确保其值在方法执行期间不可更改。当编译器生成字节码时，它会为方法分配局部变量表的槽位，并将方法的参数存储在这些槽位中。这样，在方法执行过程中，可以通过局部变量表来访问方法的参数。方法 `foo` 的参数 `arg` 在字节码中不会直接在常量池中体现，而是被分配到局部变量表中的一个槽位。字节码中的指令会直接从局部变量表中加载参数的值，而不是通过常量池访问。

从之前学习的Class文件结构可以知道局部变量与类的字段是有区别的，局部变量在常量池中没有`CONSTANT_Fieldref_info`的符号引用，自然就不可能存储访问标志的信息，甚至可能连变量名称都不一定能被保留（这取决于编译器的参数）。因此可以推断出局部变量声明为final，对运行期完全没有影响，变量的不变性仅仅由编译期中进行检查。在Javac源码中，数据及控制流分析的入口是否`flow()`方法（具体在`com.sun.tool.javac.comp.Flow`类）完成。

**解语法糖**

语法糖（Syntactic Sugar）也成为糖衣语法，是由英国计算机科学家Peter J Landin发明的一种编程术语，指的是在计算机语言中添加语法，这种语法对语言的编译结果和功能没有实际影响，但是却能更方便程序员使用该语言，通常来说语法糖能减少代码量、增加程序的可读性，从而减少代码出错的机会。Java相对于C#等其它语言来说算是低糖语言，尤其是JDK5之前的Java。“低糖”的语法让 Java 实现相同功能的代码量往往高于其他语言，也就是啰嗦。

Java中最常见的语法糖包括了泛型、变长参数、自动拆箱装箱等。Java虚拟机运行时并不直接支持这些语法，而是在编译阶段被还原成原始的基础语法结构，这个过程被称为解语法糖。

在Javac 的源码中，解语法糖的过程由 `desugar()`方法触发，在 `com.sun.tools.javac.comp.TransTypes` 类和`com.sun.tools.javac.comp.Lower` 类中完成。

**字节码生成**

字节码生成是 Javac 编译过程的最后一个阶段，在Javac 源码里面由 `com.sun.tools.javac.jvm.Gen` 类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息 (语法树、符号表)转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。例如实例构造器方法`<init>()`和类构造器方法`<clinit>()`就是在这个阶段被添加到语法树的。

> 实例构造器并不等同于默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、可访问性 (public、protected、private 或`<package>`)与当前类型一致的默认构造函数，这个工作在填充符号表阶段中就已经完成。
>
> `<init>()`和`<clinit>()`这两个构造器的产生实际上是一种代码收敛的过程，编译器会把语句块(对于实例构造器而言是`{}`块，对于类构造器而言是`static{}`块)、变量初始化(实例变量和类变量)、调用父类的实例构造器(仅仅是实例构造器，`<clinit>()` 方法中无须调用父类的 `<clinit>()` 方法，Java 虚拟机会自动保证父类构造器的正确执行，但在 `<clinit>()`方法中经常会生成调用`java.lang.Object` 的 `<init>()`)方法的代码)等操作收敛到 `<init>()和 <clinit>()`方法之中，并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由 `Gen::normalizeDefs`方法来实现。
>
> 除了生成构造器以外，还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式，如把字符串的加操作替换为 StringBuffer 或StringBuilder(取决于目标代码的版本是否大于或等于JDK 5)的`append()`操作等等。

完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到 `com.sun.tools.javac.jvm.ClassWriter` 类手上，由这个类的 `writeClass()`方法输出字节码，生成最终的 Class 文件，到此，整个编译过程宣告结束。

## 1.3 Java语法糖

几乎所有的编程语言都或多或少提供过一些语法糖来方便程序员的代码开发，这些语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。语法糖可以看作是前端编译器实现的一些“小把戏”，这些“小把戏”可能会使效率得到“大提升”，但我们也应该去了解这些“小把戏”背后的真实面貌，那样才能利用好它们，而不是被它们所迷惑。

### 1.3.1 泛型

#### Java与C#的泛型

泛型的本质是参数化类型或参数化多态的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型、泛型接口和泛型方法。泛型让程序员能够针对泛化的数据类型编写相同的算法，这极大地增强了编程语言的类型系统及抽象能力。在2004年，Java和C#同时更新了大版本，并添加了泛型的语法特性。

Java的泛型实现方式叫做类型擦除泛型，而C#的实现方式是具现化式泛型。具现化和特化、偏特化这些名词最初都是源于 C++ 模版语法中的概念，在C# 里面泛型无论在程序源码里面、编译后的中间语言表示(Intermediate Language，这时候泛型是一个占位符)里面，又或是运行期的 CLR 里面都是切实存在的，`List<int>` 与 `List<string>` 就是两个不同的类型，它们由系统在运行期生成，有着自已独立的虚方法表和类型数据。但是在Java语言的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型(Raw Typc)了，并且在相应的地方插人了强制转型代码，因此对于运行期的Java 语言来说，`ArrayList<Integer>` 与`ArrayList<String>` 其实是同一个类型，这就是“类型擦除”这个名字的含义和来源。举个例子，下面的代码在C#合法，但是在Java中是不合法的：

```java
public class TypeErasureGenerics<E> {

    public void doSomething(Object item) {
        // 编译器会提示错误：Cannot perform instanceof check against type parameter E.无法对类型参数E执行instanceof检查。
        if (item instanceof E) {
            System.out.println("item is instance of E");
        }
        E e = new E(); // 编译器会提示错误：Cannot cast from Object to E 无法从Object转换为E
        E[] eArray = new E[10]; // 编译器会提示错误：Cannot create a generic array of E 无法创建E的泛型数组
    }
}
```

上面这些是Java泛型在编码阶段产生的不良影响，C#2.0引入泛型之后，带来的显著优势之一便是对比起 Java 在执行性能上的提高，因为在使用平台提供的容器类型(如 `List<T>，Dictionary<TKey, TValue>`)时，无须像Java 里那样不厌其烦地拆箱和装箱，如果在 Java 中要避免这种损失，就必须构造一个与数据类型相关的容器类(如 IntFloatHashMap 这样的容器)。显然，这除了引入更多代码造成复杂度提高、复用性降低之外，更是丧失了泛型本身的存在价值。

Java 的类型擦除式泛型无论在使用效果上还是运行效率上，几乎是全面落后于 C# 的具现化式泛型，而它的唯一优势是在于实现这种泛型的影响范围上:擦除式泛型的实现几乎只需要在 Javac 编译器上做出改进即可，不需要改动字节码、不需要改动 Java 虚拟机，也保证了以前没有使用泛型的库可以直接运行在 Java 5.0之上。

### 1.3.2 自动装箱、拆箱与遍历循环

### 1.3.3 条件编译

# 二、后端编译与优化

## 2.1 概述

如果我们把字节码看作是程序语言的一种中间表示形式(Intermediate Representation，IR)的话，那编译器无论在何时、在何种状态下把 Class 文件转换成与本地基础设施(硬件指令集、操作系统)相关的二进制机器码，它都可以视为整个编译过程的后端。

《Java 虚拟机规范》没有具体的约束规则去限制后端编译器应该如何实现，那这部分功能就完全是与虚拟机具体实现相关的内容，如无特殊说明，本章中所提及的即时编译器都是特指 HotSpot 虚拟机内置的即时编译器，虚拟机也是特指 HotSpot 虚拟机。

## 2.2 即时编译器

### 2.2.1 解释器与编译器

目前主流的两款商用Java虚拟机里，Java程序最初都是通过解释器解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会将这些代码认定为热点代码，为了提高热点代码的执行效率，运行时虚拟机会将这些代码编译成本地机器码，并以各种手段进行代码优化，运行时完成这个任务的后端编译器叫做即时编译器。

尽管并不是所有的 Java 虚拟机都采用解释器与编译器并存的运行架构，但目前主流的商用Java 虚拟机，HotSpot、OpenJ9 等，内部都同时包含解释器与编译器，解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存(如部分嵌入式系统中和大部分的 JavaCard 应用中就只有解释器的存在)，反之可以使用编译执行来提升效率。同时，解释器还可以作为编译器激进优化的后备的逃生门，让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱(Uncommon Trap)时可以通过逆优化(Deoptimization)退回到解释状态继续执行，因此在整个Java 虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作，其交互关系如下图：

![image-20230523115418225](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230523115418225.png)

HotSpot 虚拟机中内置了两个(或三个)即时编译器，其中有两个编译器存在已久，分别被称为“客户端编译器”(Client Compiler)和“服务端编译器”(Server Compiler)，或者简称为 C1编译器和 C2编译器(部分资料和JDK 源码中C2也叫 Opto 编译器)第三个是在JDK 10 时才出现的长期目标是代替C2的 Graal编译器。在分层编译的工作模式出现以前，HotSpot虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作，程序使用哪个编译器，只取决于虚拟机运行的模式，HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用`-client`或`-server`参数去强制指定虚拟机运行在客户端模式还是服务端模式。

无论采用的编译器是客户端编译器还是服务端编译器，解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”(Mixed Mode)用户也可以使用参数`-Xint`强制虚拟机运行于“解释模式”(Interpreted Mode)，这时候编译器完全不介入工作，全部代码都使用解释方式执行。另外，也可以使用参数`-Xcomp`强制虚拟机运行于“编译模式Compiled Mode)，这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。可以通过虚拟机的`-version`命令的输出结果显示出这三种模式，如下图：

![image-20230523131845899](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230523131845899.png)

由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度更高的代码，所花费的时间便会越长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机在编译子系统中加入了分层编译的功能。

分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括:

- 第0层。程序纯解释执行，并且解释器不开启性能监控功能(Profiling)。
- 第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。
- 第2 层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。
- 第 3 层。仍然使用客户端编译器执行，开启全部性能监控，除了第 2 层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。
- 第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。

以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。各层次编译之间的交互、转换关系如下图所示：

![image-20230523132222159](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230523132222159.png)

实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量，在解释执行的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间。

### 2.2.2 编译对象与触发条件

在运行过程中被即时编译器编译的目标是热点代码，这里热点代码主要有两类：

- 被多次调用的方法
- 被多次执行的循环体

一个方法被调用的多了，方法体内代码执行的次数自然就多，所以能成为热点代码，而被多次执行的循环体指的是当一个方法只被调用过少量的几次，但是方法体内部存在循环次数较多的循环体，这样的循环体的代码也会被执行多次，因此这些代码也是热点代码。

对于这两种情况，编译的目标对象都是整个方法体，而不会是单独的循环体。第一种情况，由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式。而对于后一种情况，尽管编译动作是由循环体所触发的，热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口(从方法第几条字节码指令开始执行)会稍有不同，编译时会传入执行入口点字节码序号(Byte Code Index，BCI)。这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为“栈上替换(On tack Replacement,OSR)即方法的栈还在栈上，方法就被替换了。

以上是编译的对象，那么对象什么时候被编译呢？也就是说编译条件是什么呢？要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为被称为热点探测。目前主流的热点探测判定方式有两种，分别是：

- 基于采样的热点探测 (Sample Based Hot Spot Code Detection)。采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个(或某些) 方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高效还可以很容易地获取方法调用关系(将调用堆栈展开即可)，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻寒或别的外界因素的影响而扰乱热点探测。
- 基于计数器的热点探测 (Counter Based Hot Spot Code Detection)。采用这种方法的虚拟机会为每个方法(甚至是代码块)建立计数器，统计方法的执行次数，如果执行次数超过一定的闽值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。

这两种探测手段在商用Java虚拟机中都有使用到，比如J9用过第一种采样热点探测，而在HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法，为了实现热点计数，HotSpot为每个方法准备了两类计数器：

- 方法调用计数器（Invocation Counter）

  这个计数器用于统计方法被调用的次数，它的默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过参数`-XX:compileThreshold`来设定，当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在则优先使用编译后的本地代码来执行，如果不存在被编译过的版本，则将该方法调用计数器加一，然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值，一旦超过阈值，将会向即时编译器提交一个该方法的代码编译请求。

  如果没有做过任何设置，执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成。当编译工作完成后，这个方法的调用人口地址就会被系统自动改写成新值，下一次调用该方法时就会使用已编译的版本了，整个即时编译的交互过程如下图：

  ![image-20230523135531165](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230523135531165.png)

  在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半这个过程被称为方法调用计数器热度的衰减(Counter Decay)，而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)，进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数`-XX:-UseCounterDecay` 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。另外还可以使用`-XX:CounterHalfLifeTime` 参数设置半周期的时间，单位是秒。

- 回边计数器（Back Edge Counter,“回边”的意思就是指在循环边界往回跳转）

  回边计数器的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为“回边 (Back Edge)”，很显然建立回边计数器统计的目的是为了触发栈上的替换编译。

  关于回边计数器的闽值，虽然 HotSpot 虚拟机也提供了一个类似于方法调用计数器阙值`-XX:CompileThreshold` 的参数`-XX:BackEdgeThreshold` 供用户设置，但是当前的 HotSpot虚拟机实际上并未使用此参数，我们必须设置另外一个参数`-XX:nStackReplacePercentage`来间接调整回边计数器的阙值，其计算公式有如下两种：

  1. 虚拟机运行在客户端模式下，回边计数器闻值计算公式为:方法调用计数器值(`-XX:CompileThreshold`) 乘以OSR 比率(`-XX:OnStackReplacePercentage`)除以100。其中`-XX:OnStackReplacePercentage` 默认值为933，如果都取默认值，那客户端模式虚拟机的回边计数器的阙值为 13995。
  2. 虚拟机运行在服务端模式下，回边计数器阙值的计算公式为:方法调用计数器阙值(`-XX:CompileThreshold`)乘以(OSR 比率(`-XX:OnStackReplacePercentage`)减去解释器监控比率(`-XX:InterpreterProfilePercentage`)的差值)除以 100。其中`-XX:OnStackReplacePercentage` 默认值为140，`-XX:InterpreterProfilePercentage` 默认值为33，如果都取默认值，那服务端模式虚拟机回边计数器的闽值为 10700。

  与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进人该方法的时候就会执行标准编译过程。

  当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阙值。当超过值的时候将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果，整个执行过程如下图所示：

  ![image-20230523135648452](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230523135648452.png)

当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈值，计数器阙值一旦溢出，就会触发即时编译。

### 2.2.3 编译过程



## 2.3 提前编译器

### 2.3.1 提前编译的优劣

### 2.3.2 Jaotc的提前编译

## 2.4 编译器优化技术

优化技术概览

方法内联

逃逸分析

公共子表达式消除

数组边界检查消除