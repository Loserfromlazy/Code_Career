# Java虚拟机篇三程序编译与代码优化

**禁止转载！！**

> 本篇是Java虚拟机的学习笔记的第三篇，程序编译与代码优化。
>
> 参考资料：深入理解Java虚拟机周志明第三版以及互联网资源具体引用会在文中标注
>
> 本文大部分都是从《深入理解Java虚拟机周志明第三版》进行拷贝和引用的，目的是为了学习一遍并加深印象，同时整理重要知识点方便日后进行复习。

# 一、前端编译与优化

## 1.1 概述

在Java技术下谈编译期而没有上下文的话是很含糊的表达，因为这可能指一个前端编译器把`*.java`转换成`*.class`文件的过程；也可能是指Java虚拟机的即时编译器，运行时把字节码转换成本地机器码的过程；也可能是使用静态的提前编译器，直接把程序编译成与目标机器指令集相关的二进制代码的过程，下面是代表性产品：

- 前端编译器：javac，Eclipse JDT的ECJ增量式编译器
- 即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器
- 提前编译器：JDK的Jaotc，GNU Compiler for the Java（GCJ），Excelsior JET

一般来说Java虚拟机的设计团队选择把性能优化集中到运行期的即时编译器中，这样不仅可以让Javac产生的class文件，还可以让其它语言的如Groovy的class文件也同样享受到编译器优化带来的性能红利。 

如果把开发阶段的优化也计算进来的话，Javac 确实是做了许多针对 Java 语言编码过程的优化措施来降低程序员的编码复杂度、提高编码效率。相当多新生的 Java 语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者 Java 拟机的底层改进来支持。也就是说Java 中即时编译器在运行期的优化过程，支撑了程序执行效率的不断提升:而前端编译器在编译期的优化过程，则是支撑着程序员的编码效率和语言使用者的幸福感的提高。

## 1.2 Javac编译器

### 1.2.1 导入Javac源码

在JDK 6发布时通过了JSR 199 编译器API的提案，使得 Javac 编译器的实现代码晋升成为标准 Java 类库之一，它的源码就改为放在`JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac` 中。到了JDK9时，整个JDK 所有的 Java 类库都采用模块化进行重构划分，Javac 编译器就被挪到`jdk.compiler`模块(路径为:`JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac`)里面。

我们这里使用jdk8的版本，所以首先可以去下载openjdk的langtools的源码[openjdk-langtools下载地址](https://hg.openjdk.org/jdk8/jdk8/langtools/)。在这个网址里只需要点击zip就可以下载zip包了。然后新建一个空的Java项目，在src下手动建立com文件下，并在com文件夹下手动建立sun文件夹。注意一定要手动创建，不然IDEA会修改某些类的路径。

![image-20230424113820759](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424113820759.png)

然后将下载的源码的`src/share/classes/com/sun/*`路径下的所有代码拷贝到我们手动建的文件夹下，然后运行Main函数见到下面的输出，则Javac源码就完成了导入：

![image-20230424114055183](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424114055183.png)

如果想编译Java文件的话，只需要在main的启动参数上配置要编译的类的路径即可，如下图：

![image-20230424115056822](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424115056822.png)

### 1.2.2 Javac编译流程

Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3 个处理过程：

1. 准备过程：初始化插入式注解处理器
2. 解析与填充符号表过程：
   - 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。
   - 填充符号表。产生符号地址和符号信息。
3. 插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段
4. 分析与字节码生成过程
   - 标注检查。对语法的静态信息进行检查。
   - 数据流及控制流分析。对程序动态运行过程进行检查。
   - 解语法糖。将简化代码编写的语法糖还原为原有的形式。
   - 字节码生成。

上面的2、3、4步的关系如下（图片来自《深入理解Java虚拟机第三版》）：

![image-20230518161012500](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230518161012500.png)

代码流程如下图：

![image-20230424133853050](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424133853050.png)

#### 解析与填充符号表

我们从第二步解析与填充符号表过程开始看，这个过程包含了经典编译原理的词法分析和语法分析两个步骤：

- 首先是词法分析，它是将源代码的字符流转变为标记 (Token)集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记，如`int a = b+2`这句代码中就包含了6个标记，分别是 `int、a、=、b、+、2`，虽然关键字int由3 个字符构成，但是它只是一个独立的标记，不可以再拆分。在 Javac 的源码中，词法分析过程由 com.sun.tools.javac.parser.Scanner类来实现。
- 语法分析是根据标记序列构造抽象语法树的过程，抽象语法树(Abstract Syntax Tree，AST)是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。在 Javac 的源码中，语法分析过程由 `com.sun.tools.javac.parser.Parser`类实现，这个阶段产出的抽象语法树是以`com.sun.tools.javac.tree.JCTree` 类表示的。

生成语法树以后，编译器就不会再对源码字符流进行操作了，后续的操作都建立在抽象语法树之上。

完成了语法分析和词法分析之后，下一个阶段是对符号表进行填充的过程，也就是`enterTrees`方法要做的事情。符号表是由一组符号地址和符号信息构成的数据结构，可以简单理解为哈希表中键值对的存储形式(实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表栈结构符号表等各种形式)。符号表中所登记的信息在编译的不同阶段都要被用到。比如在语义分析的过程中，符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的声明是否一致)和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。在Javac 源代码中，填充符号表的过程由 `com.sun.tools.javac.comp.Enter` 类实现，该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，以及`package-info.java` (如果存在的话)的顶级节点。

#### 注解处理器

JDK5以后，Java语言提供了对注解的支持，注解在设置上原本与普通代码一样，都只在程序运行期间发挥作用，但在JDK6中又提出并通过了JSR-269提案，该提案设计了一组插入式注解处理器的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。可以把插入式注解处理器看作是一组编译器插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次(Round)。（流程可以对应上图）

有了编译器注解处理的标准 API后，程序员的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件中被访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。比如 Java 著名的编码效率工具Lombok，它可以通过注解来实现自动产生 getter/setter 方法、进行空置检查、生成受查异常表、产生 equals()和 hashCode()方法等等。

#### 语义分析与字节码生成

经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义逻辑是符合逻辑的。而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查，比如进行类型检查、控制流检查、数据流检查等。举个例子，比如下面的代码：

~~~java
int a = 1;
boolean b = false;
char c = 2;
~~~

后续可能出现相关的赋值运算：

~~~java
int d = a + c;
int d = b + c;
char d = a + c;
~~~

这三个操作只有一是没有错误的，其余在Java语言中是不合逻辑的，无法进行编译。我们编码是在IDE看到的由红线标注的错误提示，绝大部分都是来源于语义分析阶段的检查结果。

**标注检查**

Javac在编译过程中，语义分析过程可以分为标注检查和控制流分析两部分，分别由`attribute`和`flow`方法完成。

标注检查步骤要检查的内容包括变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。上面的赋值例子就属于标注检查的范围。在标注检查的过程中，还会顺便进行一个常量折叠的代码优化，这时Javac编译器会对源代码做的极少量耳带优化措施之一（代码优化几乎都在即时编译器进行）。举个例子，假如有变量定义`int a = 1 + 2`在抽象语法树上仍能看到字面量`1`，`2`和操作符`+`号。但是在经过常量折叠的优化之后，他们会被折叠为字面量3。由于由于编译期间进行了常量折叠，所以在代码里面定义`a=1+2`比起直接定义`a=3`来，并不会增加程序运行期哪怕仅仅一个处理器时钟周期的处理工作量。标注检查步骤在Javac源码中的实现类是`com.sun.tools.javac.comp.Attr` 类和 `com.sun.tools.javac.comp.Check` 类。

**数据及控制流分析**

数据及控制流分析是对程序上下文逻辑更进一步的验证，他可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路是否有返回值，是否所有的受检异常都被正确的处理了等问题。编译时期的数据及控制流分析与类加载时期的数据及控制流分析的目的基本上是一致的，但是校验范围会有区别，有一些校验只有在编译或运行期才能进行。举个例子：

```java
public void foo(final int arg){
    final int var = 0;
    //...
}

public void foo1(int arg){
    int var = 0;
    //...
}
```

这两个方法的字节码如下：

~~~
//foo方法字节码
public void foo(int);
descriptor: (I)V
flags: ACC_PUBLIC
Code:
  stack=0, locals=3, args_size=2
     0: return
  LineNumberTable:
    line 15: 0
//foo1方法字节码
public void foo1(int);
descriptor: (I)V
flags: ACC_PUBLIC
Code:
  stack=1, locals=3, args_size=2
     0: iconst_0
     1: istore_2
     2: return
  LineNumberTable:
    line 13: 0
    line 15: 2
~~~

> 上面的foo方法（foo1同理）字节码的含义如下：
>
> - `stack=0`：操作数栈的深度为0，表示没有需要使用的操作数栈空间。
> - `locals=3`：本地变量表的大小为3，表示方法内部使用了3个本地变量槽位。
> - `args_size=2`：方法参数的大小为2，表示方法有两个参数（注意方法默认会包括隐式的 `this` 参数，所以是两个参数）。
> - `0: return`：该方法的唯一指令是 `return`，用于从当前方法返回。
> - `LineNumberTable`：行号表指示字节码指令与源代码行号之间的映射关系，这里表示字节码指令0与源代码的第15行对应。
>
> 注意：在 Java 中，使用 `final` 修饰的局部变量会被认为是常量，编译器会对它们进行优化。对于 `final` 修饰的局部变量，编译器会将其存储在常量池中，并在需要时直接从常量池中加载，而不是从操作数栈中加载。
>
> 因此，当使用 `final` 修饰的变量时，字节码指令会直接从常量池中加载变量的值，而不需要使用操作数栈。这就是为什么在两段字节码中foo方法并没有使用操作数栈的原因。
>
> 总结就是当变量被 `final` 修饰时，编译器会对其进行优化，将其存储在常量池中，并直接从常量池加载其值，而不需要使用操作数栈。这可以减少对操作数栈的使用，从而减少字节码的大小。

从之前学习的Class文件结构可以知道局部变量与类的字段是有区别的，局部变量在常量池中没有`CONSTANT_Fieldref_info`的符号引用，自然就不可能存储访问标志的信息，甚至可能连变量名称都不一定能被保留（这取决于编译器的参数）。因此可以推断出局部变量声明为final，对运行期完全没有影响，变量的不变性仅仅由编译期中进行检查。在Javac源码中，数据及控制流分析的入口是否`flow()`方法（具体在`com.sun.tool.javac.comp.Flow`类）完成。

**解语法糖**

**字节码生成**

## 1.3 Java语法糖

几乎所有的编程语言都或多或少提供过一些语法糖来方便程序员的代码开发，这些语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。语法糖可以看作是前端编译器实现的一些“小把戏”，这些“小把戏”可能会使效率得到“大提升”，但我们也应该去了解这些“小把戏”背后的真实面貌，那样才能利用好它们，而不是被它们所迷惑。

### 1.3.1 泛型

### 1.3.2 自动装箱、拆箱与遍历循环

### 1.3.3 条件编译

# 二、后端编译与优化

## 2.1 概述

## 2.2 即时编译器

目前主流的两款商用Java虚拟机里，Java程序最初都是通过解释器解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会将这些代码认定为热点代码，为了提高热点代码的执行效率，运行时虚拟机会将这些代码编译成本地机器码，并以各种手段进行代码优化，运行时完成这个任务的后端编译器叫做即时编译器。

## 2.3 提前编译器

## 2.4 编译器优化技术

优化技术概览

方法内联

逃逸分析

公共子表达式消除

数组边界检查消除