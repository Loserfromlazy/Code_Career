# Java虚拟机篇三程序编译与代码优化

**禁止转载！！**

> 本篇是Java虚拟机的学习笔记的第三篇，程序编译与代码优化。
>
> 参考资料：深入理解Java虚拟机周志明第三版以及互联网资源具体引用会在文中标注
>
> 本文大部分都是从《深入理解Java虚拟机周志明第三版》进行拷贝和引用的，目的是为了学习一遍并加深印象，同时整理重要知识点方便日后进行复习。

# 一、前端编译与优化

## 1.1 概述

在Java技术下谈编译期而没有上下文的话是很含糊的表达，因为这可能指一个前端编译器把`*.java`转换成`*.class`文件的过程；也可能是指Java虚拟机的即时编译器，运行时把字节码转换成本地机器码的过程；也可能是使用静态的提前编译器，直接把程序编译成与目标机器指令集相关的二进制代码的过程，下面是代表性产品：

- 前端编译器：javac，Eclipse JDT的ECJ增量式编译器
- 即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器
- 提前编译器：JDK的Jaotc，GNU Compiler for the Java（GCJ），Excelsior JET

一般来说Java虚拟机的设计团队选择把性能优化集中到运行期的即时编译器中，这样不仅可以让Javac产生的class文件，还可以让其它语言的如Groovy的class文件也同样享受到编译器优化带来的性能红利。 

如果把开发阶段的优化也计算进来的话，Javac 确实是做了许多针对 Java 语言编码过程的优化措施来降低程序员的编码复杂度、提高编码效率。相当多新生的 Java 语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者 Java 拟机的底层改进来支持。也就是说Java 中即时编译器在运行期的优化过程，支撑了程序执行效率的不断提升:而前端编译器在编译期的优化过程，则是支撑着程序员的编码效率和语言使用者的幸福感的提高。

## 1.2 Javac编译器

### 1.2.1 导入Javac源码

在JDK 6发布时通过了JSR 199 编译器API的提案，使得 Javac 编译器的实现代码晋升成为标准 Java 类库之一，它的源码就改为放在`JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac` 中。到了JDK9时，整个JDK 所有的 Java 类库都采用模块化进行重构划分，Javac 编译器就被挪到`jdk.compiler`模块(路径为:`JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac`)里面。

我们这里使用jdk8的版本，所以首先可以去下载openjdk的langtools的源码[openjdk-langtools下载地址](https://hg.openjdk.org/jdk8/jdk8/langtools/)。在这个网址里只需要点击zip就可以下载zip包了。然后新建一个空的Java项目，在src下手动建立com文件下，并在com文件夹下手动建立sun文件夹。注意一定要手动创建，不然IDEA会修改某些类的路径。

![image-20230424113820759](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424113820759.png)

然后将下载的源码的`src/share/classes/com/sun/*`路径下的所有代码拷贝到我们手动建的文件夹下，然后运行Main函数见到下面的输出，则Javac源码就完成了导入：

![image-20230424114055183](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424114055183.png)

如果想编译Java文件的话，只需要在main的启动参数上配置要编译的类的路径即可，如下图：

![image-20230424115056822](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424115056822.png)

### 1.2.2 Javac编译流程

Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3 个处理过程：

1. 准备过程：初始化插入式注解处理器
2. 解析与填充符号表过程：
   - 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。
   - 填充符号表。产生符号地址和符号信息。
3. 插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段
4. 分析与字节码生成过程
   - 标注检查。对语法的静态信息进行检查。
   - 数据流及控制流分析。对程序动态运行过程进行检查。
   - 解语法糖。将简化代码编写的语法糖还原为原有的形式。
   - 字节码生成。

代码流程如下图：

![image-20230424133853050](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20230424133853050.png)

我们从第二步解析与填充符号表过程开始看，这个过程包含了经典编译原理的词法分析和语法分析两个步骤：

- 首先是词法分析，它是将源代码的字符流转变为标记 (Token)集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记，如`int a = b+2`这句代码中就包含了6个标记，分别是 `int、a、=、b、+、2`，虽然关键字int由3 个字符构成，但是它只是一个独立的标记，不可以再拆分。在 Javac 的源码中，词法分析过程由 com.sun.tools.javac.parser.Scanner类来实现。
- 语法分析是根据标记序列构造抽象语法树的过程，抽象语法树(Abstract Syntax Tree，AST)是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。在 Javac 的源码中，语法分析过程由 `com.sun.tools.javac.parser.Parser`类实现，这个阶段产出的抽象语法树是以`com.sun.tools.javac.tree.JCTree` 类表示的。

生成语法树以后，编译器就不会再对源码字符流进行操作了，后续的操作都建立在抽象语法树之上。

完成了语法分析和词法分析之后，下一个阶段是对符号表进行填充的过程，也就是`enterTrees`方法要做的事情。符号表是由一组符号地址和符号信息构成的数据结构，可以简单理解为哈希表中键值对的存储形式(实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表栈结构符号表等各种形式)。符号表中所登记的信息在编译的不同阶段都要被用到。比如在语义分析的过程中，符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的声明是否一致)和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。在Javac 源代码中，填充符号表的过程由 `com.sun.tools.javac.comp.Enter` 类实现，该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，以及`package-info.java` (如果存在的话)的顶级节点。



## 1.3 Java语法糖

# 二、后端编译与优化

## 2.1 概述

## 2.2 即时编译器

目前主流的两款商用Java虚拟机里，Java程序最初都是通过解释器解释执行的，当虚拟机发现某个方法或代码块运行特别频繁，就会将这些代码认定为热点代码，为了提高热点代码的执行效率，运行时虚拟机会将这些代码编译成本地机器码，并以各种手段进行代码优化，运行时完成这个任务的后端编译器叫做即时编译器。

## 2.3 提前编译器

## 2.4 编译器优化技术

优化技术概览

方法内联

逃逸分析

公共子表达式消除

数组边界检查消除