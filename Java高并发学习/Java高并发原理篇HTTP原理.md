# Java高并发原理篇HTTP原理

转载请声明！！！切勿剽窃他人成果。本文如有错误欢迎指正，感激不尽。

> 参考资料：Java高并发核心编程卷一尼恩编著、HTTP权威指南以及菜鸟等互联网资源

# 一、HTTP原理与Web服务器

## 1.1 高性能Web应用架构

> 术业有专攻，本小节的LVS、KeppAlived具体配置和运行，更多属于运维的工作，开发人员仅需要了解原理即可。

一般来说，高性能的IM应用还需要高性能的Web应用来进行配合。高并发、大流量的WEB应用，QPS在10万甚至千万每秒，所以使用高并发HTTP通信技术提升内部各节点的通信性能，对于提升分布式系统整体的吞吐量有着非常大的作用。

我们先来看10w级别的Web应用架构：

![image-20220805105906938](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220805105906938.png)

这种架构重点是接入层和服务层。首先是服务层，微服务计数前通过tomcat集群向外提供服务实例，在微服务技术成为主流后，服务层主要是微服务实例提供服务，并由网关提供对外统一的访问服务。其次是接入层，主要是反向代理层，利用Nginx来做反向代理。

> - Nginx将客户端请求分发给上游多个Web服务，Nginx向外暴露一个IP，Nginx与Web服务使用内网访问。
> - Ngixn需要保证负载均衡，可通过Lua脚本进行动态伸缩，动态增加Web服务节点的能力
> - Nginx需要保证高可用，任一台Web服务挂了，都可以将流量迁移至其他节点。
>
> 由于Ngixn使用Reactor模式，处理大并发请求时，内存消耗很小，3w并发下，开启10个Ngixn进程才消耗150M内存。

Nginx同样需要保证高可用，所以可以使用Nginx+KeepAlived组合，具体如下：

1. 使用两台或以上Nginx组成集群，分别部署上KeppAlived，设置成相同的虚ip共下游访问
2. 当一台Nginx挂了，KeepAlived能探测到，并将流量自动迁移到另一台Nginx上

如果流量一直上升，则可以使用LVS+KeepAlived组合实现Nginx的可拓展比如百万级别的Web应用架构：

![image-20220805110518046](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220805110518046.png)

这种架构重点在负载均衡层和客户端层：

在客户端层，需要在DNS服务器上使用负载均衡机制，DNS负载均衡很简单，属于运维层面的技术，就是在DNS服务器上配置多个A记录，在一个域名下添加多个IP，由DNS服务器进行多个IP的负载均衡，甚至可以按照就近原则，为用户返回最近的服务器IP地址。

DNS服务器负载均衡也有很多缺点：首先无法动态调整主机地址的权重，其次DNS通常会缓存查询响应，以便更迅速的向用户提供查询服务，如果某主机宕机，那么第一时间移除服务器IP也无济于事。

由于DNS负载均衡无法满足高可用，所以仅用作客户端层面的简单负载均衡，同时引入一个专门的负载均衡层，通过LVS+KeepAlived组合达到高可用和负载均衡的目的。

> LVS是Linux Virtual Server的简写，是一个虚拟的服务器集群系统。

LVS+KeepAlived具体方案如下：

1. 使用两台或以上LVS组成集群，分别部署上KeppAlived，设置成相同的虚拟IP（VIP）供下游访问。KeepAlived对LVS负载均衡调度器实现健康监控、热备切换，具体来说，对服务器中的各个节点进行健康检查，自动移除失效节点，恢复后在重新加入，从而保证LVS高可用
2. 在LVS系统上可配置多个接入层Nginx服务器集群，由LVS完成高速的请求分发和接入层的负载均衡。

LVS常常使用直接路由方式（DR）进行负载均衡，数据在分发过程中不修改IP地址，只修改mac地址，由于实际处理请求的真实物理IP地址和数据请求目的IP地址一致，所以响应数据包可以不需要通过LVS负载均衡服务器进行地址转换，而是直接返回给用户浏览器，避免LVS负载均衡服务器网卡带宽成为瓶颈。此种方式又称作三角传输模式，具体如下图所示

![image-20220805130115493](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220805130115493.png)

使用三角传输模式的链路层负载均衡是目前大型网站使用最广泛的一种负载均衡手段，目前，LVS（Linux Virtual Server）是Linux平台上最好的三角传输模式软件负载均衡开源产品。

> LVS与Nginx区别？
>
> Nginx主要用于四层、七层负载均衡，平时Nginx进行Web应用的负载属于七层负载均衡，而LVS主要用于二层、四层负载均衡，但由于性能原因更多用于二层负载均衡。
>
> 二层、四层、七层负载均衡？
>
> 均属于OSI模型的概念。二层是指OSI模型的数据链路层主要根据报文中的链路层地址，比如MAC地址，在多个上游服务器选择一个RS（Real Server）真实服务器，然后进行报文转发和处理，实现负载均衡
>
> 四层是指OSI模型的传输层，主要是通过修改报文中的目标ip地址和端口，在多个上游TCP/UDP服务器之间选择一个RS，然后进行报文转发，实现负载均衡
>
> 七层是指OSI模型的应用层，主要根据报文中的应用层内容如HTTP协议URI、Cookie信息，虚拟主机Host名称等，在多个上游应用层服务器之间选择一个RS，然后进行报文转发，实现负载均衡

LVS的转发分为NAT模式（四层）和DR模式（二层），具体内容如下：

1. NAT：NAT是一种外网和内网地址映射的技术，是一种网络地址转换技术，NAT模式下网络数据包的进出都要经过LVS的处理，LVS作为RS的网关。

   > NAT 包括目标地址转换（DNAT）和源地址转换（SNAT）。当包到达 LVS 时，LVS需要做目标地址转换（DNAT）：将目标IP改为RS的IP，RS在接收到数据包以后，仿佛是客户端直接发给它的一样；RS处理完返回响应时，源IP是RS的IP，目标IP是客户端的IP，这时LVS 需要做做源地址转换（SNAT），将包的源地址改为VIP（对外的IP），这样这个包对客户端看起来就仿佛是LVS直接返回给它的

2. DR：DR也叫直接路由、三角传输模式。DR模式下需要LVS和RS集群绑定到同一个VIP（虚拟ip）上，与NAT不同的是，请求由LVS接收，处理有由RS直接返回给用户。

   > 一个请求过来时，LVS 只需要将网络帧的 MAC 地址修改为某一台 RS 的 MAC，该包就会被转发到相应的 RS 处理，注意此时的源 IP 和目标 IP 都没变，LVS 只是做了一下移花接木。RS 收到 LVS 转发来的包时，链路层发现 MAC 是自己的，到上面的网络层，发现 IP 也是自己的，于是这个包被合法地接受，RS 感知不到前面有 LVS 的存在。而当 RS 返回响应时，只要直接向源IP（即客户端的 IP）返回即可，不再经过LVS转发。这里有个系统运维的要点：RS的Loopback口和需要和LVS设备上存在着相同的VIP地址，这样响应才能直接返回到客户端。
   >
   > 在DR负载均衡模式下，数据在分发过程中不修改IP地址，只修改MAC地址，由于实际处理请求的真实物理IP地址和数据请求目的IP地址一致，所以不需要通过负载均衡服务器进行地址转换，其最大的优势为：可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈，因此，DR模式具有较好的性能，是目前大型网站使用最广泛的一种负载均衡手段

## 1.2 HTTP应用层协议

HTTP是一个应用层的面向对象的协议，是一种请求-响应模式的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统，是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（Hyper Text），这成为了HTTP超文本传输协议标准架构的发展根基。最终，万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究HTTP协议，最终发布了一系列的RFC文档，其中著名的RFC 2616定义了HTTP 1.1协议。

### 1.2.1 HTTP的请求URL

URL提供了一种定位因特网上任意资源的手段，但这些资源是可以通过各种不同的方案（比如HTTP、FTP、SMTP）来访问的，因此URL语法会随方案的不同而有所不同。大部分URL都遵循通用的URL语法，而且不同URL方案的风格和语法都有不少重叠。大多数URL方案的URL语法都建立在这个由9部分构成的通用格式上：

~~~
<scheme>://<user>:<password>@<host>:<port>/<path>; <params>?<query>#<frag>
~~~

几乎没有哪个URL包含了所有这些组件。URL最重要的3个部分是方案、主机和路径。见下表：

| 组件 | 描述                                                         | 默认值       |
| ---- | ------------------------------------------------------------ | ------------ |
| 方案 | 访问服务器获取资源时的协议                                   | 无           |
| 用户 | 某些方案访问资源时需要的用户名                               | 匿名         |
| 密码 | 用户名后面可能要包含的密码，中间用冒号分隔                   | E-mail地址   |
| 主机 | 资源宿主服务器的主机名或IP地址                               | 无           |
| 端口 | 资源宿主服务器正在监听的端口号，很多方案都有默认的端口号，比如HTTP的默认是80 | 每个方案特有 |
| 路径 | 服务器上资源的本地名，由一个斜杠将其与前面的URL组件分隔开来。 | 无           |
| 参数 | 某些方案会用这个组件来指定输入参数。参数为`名/值对`。URL中可以包含多个参数字段，他们之间以及路径用分号分隔 | 无           |
| 查询 | 某些方案会用这个组件传递参数已激活应用程序，查询组件内用没有通用格式，用字符？将其与URL其余部分分割开来 | 无           |
| 片段 | 一小片或一部分资源的名字，引用对象时，不会将frag字段传送给服务器，这个字段是在客户端内部使用的，通过#将其与URL其余部分分隔开来。 | 无           |

1. 方案:方案实际上是规定如何访问指定资源的主要标识符，它会告诉负责解析URL的应用程序应该使用什么协议。方案组件必须以一个字母符号开始，由第一个“:”符号将其与URL的其余部分分隔开来。方案名是大小写无关的，因此URL`http://www.demo.com`和`HTTP://www.demo.com`是等价的。

2. 主机与端口：主机组件标识了因特网上能够访问资源的宿主机器。可以用主机名（`www.demo.com`），或者IP地址来表示主机名。端口组件标识了服务器正在监听的网络端口。对下层使用了TCP协议的HTTP来说，默认端口号为80。

3. 用户和密码组件：很多服务器都要求输入用户名和密码才会允许用户访问数据。FTP服务器就是这样一个常见的实例。这里有几个例子：

   比如`ftp://ftp.demo.edu/pub/gnu`此例子没有用户或密码组件，只有标准的方案、主机和路径。如果某应用程序使用的URL方案要求输入用户名和密码，比如FTP，但用户没有提供，它通常会插入一个默认的用户名和密码anonymous（匿名用户）作为你的用户名，并发送一个默认的密码（Internet Explorer会发送IEUser, Netscape Navigator则会发送mozilla）。

   再比如`ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu`这个anonymous的用户名与主机组件组合在一起，看起来就像E-mail地址一样。字符“@”将用户和密码组件与URL的其余部分分隔开来。

   再来看`ftp://anonymous:my passwd@ftp.demo.edu/pub/gnu`此例子指定了用户名（anonymous）和密码（my passwd），两者之间由字符“:”分隔。

4. URL的路径组件：路径说明了资源位于服务器的什么地方。路径通常很像一个分级的文件系统路径。比如：`http://www.demo.com:80/seasonal/index-fall.html`这个URL中的路径为`/seasonal/index-fall.html`，很像UNIX文件系统中的文件系统路径。

   路径是服务器定位资源时所需的信息。可以用字符“/”将HTTP URL的路径组件划分成一些路径段（path segment）。每个路径段都有自己的参数（param）组件。

5. 参数：负责解析URL的应用程序需要这些协议参数来访问资源。否则，另一端的服务器可能就不会为请求提供服务，或者更糟糕的是，提供错误的服务。比如，像FTP这样的协议，有两种传输模式，二进制和文本形式。你肯定不希望以文本形式来传送二进制图片，这样的话，二进制图片可能会变得一团糟。

   为了向应用程序提供它们所需的输入参数，以便正确地与服务器进行交互，URL中有一个参数组件。这个组件就是URL中的名值对列表，由字符“; ”将其与URL的其余部分（以及各名值对）分隔开来。它们为应用程序提供了访问资源所需的所有附加信息。比如：`ftp://ftp.demo.edu/pub/gnu; type=d`在这个例子中，有一个参数type=d，参数名为type，值为d。

   HTTP URL的路径组件可以分成若干路径段。每段都可以有自己的参数。比如：`http://www.demo.com/hammers;sale=false/index.html;graphics=true`这个例子就有两个路径段，hammers和index.html。hammers路径段有参数sale，其值为false。index.html段有参数graphics，其值为true。

6. 查询字符串：很多资源，比如数据库服务，都是可以通过提问题或进行查询来缩小所请求资源类型范围的。

   我们来看一个URL：`http://www.demo.com/check.do?item=12731`这个URL的大部分都与我们见过的其他URL类似。只有问号（?）右边的内容是新出现的。这部分被称为查询（query）组件。URL的查询组件和标识网关资源的URL路径组件一起被发送给网关资源。基本上可以将网关当作访问其他应用程序的访问点。

   按照常规，很多网关都希望查询字符串以一系列“名/值”对的形式出现，名值对之间用字符“&”分隔。比如`http://www.demo.com/check.do?item=12731&color=blue`在这个例子中，查询组件有两个名/值对：item=12731和color=blue。

7. 片段：有些资源类型，比如HTML，除了资源级之外，还可以做进一步的划分。比如，对一个带有章节的大型文本文档来说，资源的URL会指向整个文本文档，但理想的情况是，能够指定资源中的那些章节。为了引用部分资源或资源的一个片段，URL支持使用片段（frag）组件来表示一个资源内部的片段。比如，URL可以指向HTML文档中一个特定的图片或小节。片段挂在URL的右手边，最前面有一个字符“#”。比如：`http://www.demo.com/tools.html#drills`在这个例子中，片段drills引用了Demo的Web服务器上页面/tools.html中的一个部分。这部分的名字叫做drills。

### 1.2.2 HTTP协议的报文

如果说HTTP是因特网的信使，那么HTTP报文就是它用来搬东西的包裹了。HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”及“下游”都是用来描述报文方向的。

> 不管是请求报文还是响应报文，所有报文都会向下游流动。所有报文的发送者都在接收者的上游。

HTTP报文由起始行（start line）、首部（header）块，以及可选的、包含数据的主体（body）三部分组成。

所有的HTTP报文都可以分为两类：请求报文（request message）和响应报文（response message）。

#### 报文的语法

所有的HTTP报文都可以分为两类：请求报文和响应报文。请求报文会向Web服务器请求一个动作。响应报文会将请求的结果返回给客户端。请求和响应报文的基本报文结构相同

请求报文格式：

~~~
<method> <request-URL> <version>
<headers>
<entity-body>
~~~

响应报文格式：

~~~
<version> <status> <reason-phrase>
<headers>
<entity-body>
~~~

- method（方法）

  客户端希望服务器对资源的动作，常见的有GET、POST

- 请求URL（request-URL）

  命名了资源的URL路径

- 版本（version）

  报文所使用的HTTP版本，格式：`HTTP/<major>.<minor>`例如：`HTTP /1.1`

- 状态码（status）

  三位数字用于描述请求过程中发生的情况

- 原因短语（reason-phrase）

  数字状态码的可读版本，包含行终止序列之前的所有文本

- 头部（header）

  可以有零个或多个首部，每个首部包含一个名字跟着一个冒号，跟着一个可选的空格，跟着一个值，最后是一个CRLF（空行）

- 主体部分（entity-body）

  实体的主体部分包含由一个任意数据组成的数据块。并不是所有的报文都包含主体部分

#### 报文的组成

**起始行**

所有的HTTP报文都以一个起始行作为开始。其中包括请求行和响应行。

请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为请求行，包含了一个方法和一个请求URL，这个方法描述了服务器应该执行的操作，请求URL描述了要对哪个资源执行这个方法。

响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为响应行，包含了响应报文使用的HTTP版本、数字状态码，以及描述操作状态的文本形式的原因短语。

请求的起始行以方法作为开始，常见的方法如下：

| 方法    | 描述                                               | 是否包含主体 |
| ------- | -------------------------------------------------- | ------------ |
| GET     | 从服务器获取一份文档                               | 否           |
| HEAD    | 只从服务器获取文档首部                             | 否           |
| POST    | 向服务器发送需要处理的数据                         | 是           |
| PUT     | 将请求的主体存储在服务器上                         | 是           |
| TRACE   | 瑞可能经过代理服务器传送到服务器上去的报文机型追踪 | 否           |
| OPTIONS | 决定可以在服务器上执行哪些方法                     | 否           |
| DELETE  | 从服务器上删除文档                                 | 否           |

方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。常见的状态码：

| 整体范围 | 已定义范围 | 分类       |
| -------- | ---------- | ---------- |
| 100-199  | 100-101    | 信息提示   |
| 200-299  | 200-206    | 成功       |
| 300-399  | 300-305    | 重定向     |
| 400-499  | 400-415    | 客户端错误 |
| 500-599  | 500-505    | 服务器错误 |

原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解释。比如，在行HTTP/1.0200 OK中，OK就是原因短语。原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者将其传送给用户，用以说明在请求期间发生了什么情况

**首部**

跟在起始行后面的就是零个、一个或多个HTTP首部字段。HTTP首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名/值对的列表。例如Content-length:19。具体的详细的首部信息可以自行查阅。

首部和方法配合工作，共同决定了客户端和服务器能做什么事情，首部可以主要分为五种类型：

- 通用首部

  这些是客户端和服务器都可以使用的通用首部。可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能。比如，Date首部就是一个通用首部：

  ~~~
  Date: Tue, 3 Oct 1999 02:17:03 GMT
  ~~~

- 请求首部

  请求首部是请求报文特有的。它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据,例如下面Accept首部就用来告知服务器客户端会接受与其请求相符的任意媒体类型:

  ~~~
  Accept： */*
  ~~~

- 响应首部

  响应报文有自己的首部集，以便为客户端提供信息（比如，客户端在与哪种类型的服务器进行交互）。例如下面Server首部就用来告知客户端它在与openresty服务器进行交互

  ~~~
  server: openresty
  ~~~

- 实体首部

  实体首部指的是用于应对实体主体部分的首部。比如，可以用实体首部来说明实体主体部分的数据类型。例如下面Content-Type首部告知应用程序，数据是以utf-8字符集表示的HTML文档

  ~~~
  Content-Type: text/html; charset=utf-8
  ~~~

- 扩展首部

  扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的HTTP规范中去。即使不知道这些扩展首部的含义，HTTP程序也要接受它们并对其进行转发。

**主体**

HTTP报文的第三部分是可选的实体主体部分。实体的主体是HTTP报文的负荷。就是HTTP要传输的内容。HTTP报文可以承载很多类型的数字数据：图片、视频、HTML文档、软件应用程序、信用卡事务、电子邮件等。

## 1.3 HTTP协议的演进

HTTP1.1之前，由于无状态等特点，每次请求都需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户端在短时间多次请求同一个资源，但是服务器并不能区分是否已经响应过用户的请求，所以每次请求都需要重新响应。为了节省资源消耗，HTTP协议也进行了发展和改进：

| 版本     | 产生时间 | 内容                                                         | 发展状况         |
| -------- | -------- | ------------------------------------------------------------ | ---------------- |
| HTTP/0.9 | 1991     | 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求 | 没有作为正式标准 |
| HTTP/1.0 | 1996     | 传输内容格式不限制，增加PUT、PATCH、HEAD、OPTIONS、DELETE    | 正式作为标准     |
| HTTP/1.1 | 1997     | 持久连接（长连接）、节约带宽、HOST域、管道机制、分块传输协议 | 2015年前广泛使用 |
| HTTP/2.0 | 2015     | 多路复用、服务器推送、头信息压缩、二进制协议等等             | 逐渐覆盖市场     |

### HTTP 1.0

HTTP一共有三个版本的演进，第一个版本为0.9但仅支持GET请求，且不支持协议头，因此也支持纯文本。

第二个版本是HTTP1.0。增加了以下特性：

1. 请求和响应头
2. 响应对象以一个响应状态行开始
3. 响应对象不只限于超文本
4. 支持GET、HEAD、POST
5. 支持长连接（以扩展的方式支持）、缓存及身份认证
6. 请求行必须在尾部添加协议版本，且必须包含头消息

HTTP 1.0版本使用Content-Type字段来表示客户端请求服务端的数据是什么格式，服务端使用Content-Type来表示具体的响应体中的媒体类型信息，比如`Content-Type: text/html`。媒体类型（MediaType），全称为互联网媒体类型（Internet Media Type），也叫做MIME（多用途互联网邮件扩展）类型。具体的常用类型请自行查阅相关资料。MIME（多用途互联网邮件扩展）类型，每个值包括一级类型和二级类型，之间用斜杠分隔。除了预定义的类型，厂商也可以自定义类型：`application/vnd.debian.binary-package`。MIME还可以在尾部使用分号，添加参数，比如：`Content-Type: text/html;charset=utf-8`

HTTP1.0工作方式是每次发送一个请求就需要一个TCP连接，当服务器响应后就会关闭这次连接，下一次请求再次建立TCP连接，这点和HTTP0.9相同。但是这样传输性能比较差为了解决这个问题，有些浏览器在请求时，对HTTP 1.0版本进行了扩展，增加了一个非标准的Connection头部字段，如果要对传输层的HTTP连接进行复用，Connection头部的值如下：`Connection: keep-alive`这个头部字段要求服务器不要关闭TCP连接，以便其他HTTP请求复用，同样服务器需要回应这个字段`Connection: keep-alive`如果连接的两端都有“Connection: keep-alive”头部，则一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，Connection不是标准字段，不同服务端实现的行为可能不一致，因此并不是提高传输性能的最终解决办法。

### HTTP 1.1

Http1.1版本引入了很多关键技术，主要包括：持久连接、管道机制、分块传输编码、字节范围（Range）请求等等。以下是每个新技术的介绍：

HTTP1.1版本的最大变化就是引入了持久连接（长连接），即下层的TCP连接默认不关闭，可以被多个请求复用，而且报文不用声明Connection: keep-alive头部值。在连接建立后，客户端和服务器端都可以进行通信检测，如果发现对方在一段时间没有活动，就可以主动关闭TCP连接。不过，相对规范的做法是，客户端在最后一个请求时，发送带Connection:close请求头的HTTP报文。对于同一个域名（带端口），大多数浏览器允许同时建立6个持久连接，这些持久连接在降低了传输延迟的同时，也提高了带宽的利用率。

HTTP 1.1版本加入了管道机制，在同一个TCP连接里，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率；举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。

HTTP1.1在客户端请求头中新增了Host字段，用来指定服务器的域名。在1.0版本中协议认为每台服务器都绑定唯一的ip地址，因此URL没有主机名，但随着虚拟主机的发展，在一台服务器上可以存在多个虚拟主机，并且共享同一个ip地址甚至端口号，而有了Host字段，就可以将请求发送到同一台服务器上的不同网站。在1.1版本请求消息如果没有Host字段，很多服务器会报400的错误。

HTTP 1.1版本加入了一个新的状态码100（Continue），服务端通过该响应码告知客户端继续发送后面的请求。例如，客户端事先发送一个只带令牌的Authorization头域而不带Body的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器通过权限校验而接收此请求，就回送响应码100，客户端就可以继续发送带实体的完整请求了。

HTTP 1.1版本加入了一些Cache的新特性，当缓存对象的Age超过Expire时，缓存对象变为Stale对象之后，HTTP 1.0版本会直接抛弃Stale对象，HTTP 1.1版本则可以不需要直接抛弃Cache中的Stale对象，而是与源服务器进行重新激活（revalidation）操作

HTTP 1.1版本支持传送内容的一部分，也就是“字节范围请求”。当客户端已经拥有的请求资源的一部分后，只需要跟服务器请求另外的部分资源即可。“字节范围请求”是支持文件断点续传的基础。“字节范围请求”是通过Range头部实现的，HTTP 1.0版本每次传送文件都是只能从文件头开始，即0字节处开始。而在HTTP 1.1版本中，客户端通过`Range:bytes=XX`的请求头部值，表示要求服务器从文件的“XX”字节处开始传送，也就是断点续传。其对应的部分内容的响应码不是200，而是使用专门的响应码206（Partial Content）

> 关于断点续传，我在我自己的笔记上[Java爬虫第2.4节](https://www.cnblogs.com/yhr520/p/15495801.html)中写了一些用HttpClient写的分段下载的案例，所有的分段下载，断点续传本质上都是通过range字段对文件进行拆分。

HTTP 1.1版本支持分块（Chunked）传输编码。分块传输编码（Chunked transfer encoding）是一种新数据传输机制，允许服务端将数据分成多个部分发送到客户端。普通的服务端响应，会将响应数据的长度通过Content-Length字段告诉客户端。但是，使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。而对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用“流模式”发送取代“缓存模式”发送。因此，HTTP 1.1版本规定请求或者响应报文可以不使用Content-Length字段告知长度，而使用分块传输编码（Chunked transfer encoding）字段。只要请求或回应的头部有Transfer Encoding字段，就表明数据将由数量未定的数据块组成。`Transfer-Encoding: chunked`每个分块报文的非空的数据块之前，会有一个16进制的数值，表示当前块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。分块传输编码（Chunked transfer encoding）的具体传输规则为：

1. 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。
2. 每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括分块长度后面的结尾CRLF(\r\n)的长度，也不包括分块数据后面的结尾CRLF(\r\n)的长度。
3. 最后一个分块的长度值必须为 0，对应的分块数据没有内容，表示所有的Body数据传输完成

下面举一个例子：

~~~
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked
25
This is the data in the first chunk
1C
and this is the second one
3
con
8
sequence
0
~~~

上面示例中的20、1C、3、8、0都是16进制的分片内容净长度，且后面的报文不需要HTTP头部，因为1.1版本的连接是持久的，接收端最后通过一个长度为0的分片，表示当前的Body在这里结束即可。

### HTTP 2.0

未完结

## 1.4 基于Netty实现简单的Web服务器

Netty天生是异步事件驱动的架构，在性能和可靠性上都十分优异，非常适合作为WEB服务器使用，相比于传统的Tomcat的Web容器，基于Netty的Web服务器更小巧灵活且定制性更强。我们这里基于Netty实现的Web服务器非常简单就是将HTTP请求的请求头，请求体等内容回显出来。

此简单web服务器的Netty流水线如下图：

![image-20220811124935470](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220811124935470.png)

### 1.4.1 Netty处理HTTP请求

通常HTTP协议通信过程中，客户端和服务器的交互过程如下：

1. 客户端向服务器端发送HTTP请求
2. 服务端对HTTP请求进行解析
3. 服务端发送HTTP响应报文
4. 客户端解析HTTP响应的应用层协议内容

在Netty中已经内置了这些编解码的处理器，大致如下：

- HttpRequestDecoder：HTTP请求编码器，这是一个入站处理器，间接的继承了ByteToMessageDecoder，将ByteBuf缓冲区解码成HttpRequest和HttpContent实例。并且解码时会处理好分块类型和固定长度类型的HTTP请求报文。

- HttpResponseEncoder：响应编码器，是一个出站处理器，把代表响应HttpResponse和HttpContent内容实例编码成ByteBuf。

- HttpServerCodec：编解码器。

- HttpObjectAggregator：HttpObject实例聚合器，这是入站处理器，通过此类，可以把HttpMessage头部实例和一个或多个HttpContent内容实例最终聚合成FullHttpRequest。

  ![image-20220811140542612](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220811140542612.png)

  > HttpRequest、HttpContent、FullHttpRequest等都是HttpObject的子类。

  在请求请Request Body处理过程中，会涉及到Content-Length和Trunked两种类型的请求体，但是其处理差异被HttpRequestDecoder协议解码器所屏蔽，它们的最终出站对象是一致的，当HttpObjectAggregator发现有入站包为LastHttpContent实例入站时，代表HTTP请求数据协议解析完成，此时，会将所收到的全部HttpObject实例，封装一个FullHttpRequest整体请求实例。通过聚合器HttpObjectAggregator处理之后，输出的都是FullHttpRequest实例。然后可以通过该FullHttpRequest实例获取到所有与HTTP请求的所有内容。

- QueryStringDecoder：把HTTP请求URI分成Path路径和Key-Value参数键值对，同一次请求该解码器仅能使用一次。

综上，整体来说，如果相对HTTP请求报文进行读取，只要在流水线上配置好两个内置处理器HttpRequestDecoder和HttpObjectAggregator即可。

### 1.4.2 Netty的报文解码

通过内置处理器HttpRequestDecoder和HttpObjectAggregator对HTTP请求报文进行解码后，会将HTTP请求封装成一个FullHttpRequest实例，然后发送给下一站。

Netty内置的HTTP请求报文对应的类主要有以下几个：

1. FullHttpRequest：包含整个HTP请求的信息，包含对HttpRequest首部和HttpContent请求体的组合
2. HttpRequest：请求首部，主要包含对HTTP请求行和请求头Header的封装
3. HttpContent：是对Http请求体的封装，本质上就是一个ByteBuf缓冲区实例。如果ByteBuf长度固定而请求体又太长的话那么就会产生多个HttpContent对象，解码时最后一个返回LastHttpContent，表示对请求体的解码已经完成。
4. HttpMethod：对HTTP请求方法的封装
5. HttpVersion：对HTTP版本的封装，该类定义了HTTP/1.0和HTTP/1.1两个协议版本
6. HttpHeaders：包含对HTTP报文请求头Header的封装和相关操作。

### 1.4.3 Netty的HTTP响应

### 1.4.4 回显业务处理器

### 1.4.5 测试

# 二、高并发HTTP的核心原理

# 三、WebSocket原理

# 四、SSL/TLS核心原理