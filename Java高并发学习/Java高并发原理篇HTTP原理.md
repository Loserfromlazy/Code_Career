# Java高并发原理篇HTTP原理

转载请声明！！！切勿剽窃他人成果。本文如有错误欢迎指正，感激不尽。

> 参考资料：Java高并发核心编程卷一尼恩编著、HTTP权威指南以及菜鸟等互联网资源

# 一、HTTP原理与Web服务器

## 1.1 高性能Web应用架构

> 术业有专攻，本小节的LVS、KeppAlived具体配置和运行，更多属于运维的工作，开发人员仅需要了解原理即可。

一般来说，高性能的IM应用还需要高性能的Web应用来进行配合。高并发、大流量的WEB应用，QPS在10万甚至千万每秒，所以使用高并发HTTP通信技术提升内部各节点的通信性能，对于提升分布式系统整体的吞吐量有着非常大的作用。

我们先来看10w级别的Web应用架构：

![image-20220805105906938](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220805105906938.png)

这种架构重点是接入层和服务层。首先是服务层，微服务计数前通过tomcat集群向外提供服务实例，在微服务技术成为主流后，服务层主要是微服务实例提供服务，并由网关提供对外统一的访问服务。其次是接入层，主要是反向代理层，利用Nginx来做反向代理。

> - Nginx将客户端请求分发给上游多个Web服务，Nginx向外暴露一个IP，Nginx与Web服务使用内网访问。
> - Ngixn需要保证负载均衡，可通过Lua脚本进行动态伸缩，动态增加Web服务节点的能力
> - Nginx需要保证高可用，任一台Web服务挂了，都可以将流量迁移至其他节点。
>
> 由于Ngixn使用Reactor模式，处理大并发请求时，内存消耗很小，3w并发下，开启10个Ngixn进程才消耗150M内存。

Nginx同样需要保证高可用，所以可以使用Nginx+KeepAlived组合，具体如下：

1. 使用两台或以上Nginx组成集群，分别部署上KeppAlived，设置成相同的虚ip共下游访问
2. 当一台Nginx挂了，KeepAlived能探测到，并将流量自动迁移到另一台Nginx上

如果流量一直上升，则可以使用LVS+KeepAlived组合实现Nginx的可拓展比如百万级别的Web应用架构：

![image-20220805110518046](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220805110518046.png)

这种架构重点在负载均衡层和客户端层：

在客户端层，需要在DNS服务器上使用负载均衡机制，DNS负载均衡很简单，属于运维层面的技术，就是在DNS服务器上配置多个A记录，在一个域名下添加多个IP，由DNS服务器进行多个IP的负载均衡，甚至可以按照就近原则，为用户返回最近的服务器IP地址。

DNS服务器负载均衡也有很多缺点：首先无法动态调整主机地址的权重，其次DNS通常会缓存查询响应，以便更迅速的向用户提供查询服务，如果某主机宕机，那么第一时间移除服务器IP也无济于事。

由于DNS负载均衡无法满足高可用，所以仅用作客户端层面的简单负载均衡，同时引入一个专门的负载均衡层，通过LVS+KeepAlived组合达到高可用和负载均衡的目的。

> LVS是Linux Virtual Server的简写，是一个虚拟的服务器集群系统。

LVS+KeepAlived具体方案如下：

1. 使用两台或以上LVS组成集群，分别部署上KeppAlived，设置成相同的虚拟IP（VIP）供下游访问。KeepAlived对LVS负载均衡调度器实现健康监控、热备切换，具体来说，对服务器中的各个节点进行健康检查，自动移除失效节点，恢复后在重新加入，从而保证LVS高可用
2. 在LVS系统上可配置多个接入层Nginx服务器集群，由LVS完成高速的请求分发和接入层的负载均衡。

LVS常常使用直接路由方式（DR）进行负载均衡，数据在分发过程中不修改IP地址，只修改mac地址，由于实际处理请求的真实物理IP地址和数据请求目的IP地址一致，所以响应数据包可以不需要通过LVS负载均衡服务器进行地址转换，而是直接返回给用户浏览器，避免LVS负载均衡服务器网卡带宽成为瓶颈。此种方式又称作三角传输模式，具体如下图所示

![image-20220805130115493](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220805130115493.png)

使用三角传输模式的链路层负载均衡是目前大型网站使用最广泛的一种负载均衡手段，目前，LVS（Linux Virtual Server）是Linux平台上最好的三角传输模式软件负载均衡开源产品。

> LVS与Nginx区别？
>
> Nginx主要用于四层、七层负载均衡，平时Nginx进行Web应用的负载属于七层负载均衡，而LVS主要用于二层、四层负载均衡，但由于性能原因更多用于二层负载均衡。
>
> 二层、四层、七层负载均衡？
>
> 均属于OSI模型的概念。二层是指OSI模型的数据链路层主要根据报文中的链路层地址，比如MAC地址，在多个上游服务器选择一个RS（Real Server）真实服务器，然后进行报文转发和处理，实现负载均衡
>
> 四层是指OSI模型的传输层，主要是通过修改报文中的目标ip地址和端口，在多个上游TCP/UDP服务器之间选择一个RS，然后进行报文转发，实现负载均衡
>
> 七层是指OSI模型的应用层，主要根据报文中的应用层内容如HTTP协议URI、Cookie信息，虚拟主机Host名称等，在多个上游应用层服务器之间选择一个RS，然后进行报文转发，实现负载均衡

LVS的转发分为NAT模式（四层）和DR模式（二层），具体内容如下：

1. NAT：NAT是一种外网和内网地址映射的技术，是一种网络地址转换技术，NAT模式下网络数据包的进出都要经过LVS的处理，LVS作为RS的网关。

   > NAT 包括目标地址转换（DNAT）和源地址转换（SNAT）。当包到达 LVS 时，LVS需要做目标地址转换（DNAT）：将目标IP改为RS的IP，RS在接收到数据包以后，仿佛是客户端直接发给它的一样；RS处理完返回响应时，源IP是RS的IP，目标IP是客户端的IP，这时LVS 需要做做源地址转换（SNAT），将包的源地址改为VIP（对外的IP），这样这个包对客户端看起来就仿佛是LVS直接返回给它的

2. DR：DR也叫直接路由、三角传输模式。DR模式下需要LVS和RS集群绑定到同一个VIP（虚拟ip）上，与NAT不同的是，请求由LVS接收，处理有由RS直接返回给用户。

   > 一个请求过来时，LVS 只需要将网络帧的 MAC 地址修改为某一台 RS 的 MAC，该包就会被转发到相应的 RS 处理，注意此时的源 IP 和目标 IP 都没变，LVS 只是做了一下移花接木。RS 收到 LVS 转发来的包时，链路层发现 MAC 是自己的，到上面的网络层，发现 IP 也是自己的，于是这个包被合法地接受，RS 感知不到前面有 LVS 的存在。而当 RS 返回响应时，只要直接向源IP（即客户端的 IP）返回即可，不再经过LVS转发。这里有个系统运维的要点：RS的Loopback口和需要和LVS设备上存在着相同的VIP地址，这样响应才能直接返回到客户端。
   >
   > 在DR负载均衡模式下，数据在分发过程中不修改IP地址，只修改MAC地址，由于实际处理请求的真实物理IP地址和数据请求目的IP地址一致，所以不需要通过负载均衡服务器进行地址转换，其最大的优势为：可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈，因此，DR模式具有较好的性能，是目前大型网站使用最广泛的一种负载均衡手段

## 1.2 HTTP应用层协议

HTTP是一个应用层的面向对象的协议，是一种请求-响应模式的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统，是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（Hyper Text），这成为了HTTP超文本传输协议标准架构的发展根基。最终，万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究HTTP协议，最终发布了一系列的RFC文档，其中著名的RFC 2616定义了HTTP 1.1协议。

### 1.2.1 HTTP的请求URL

URL提供了一种定位因特网上任意资源的手段，但这些资源是可以通过各种不同的方案（比如HTTP、FTP、SMTP）来访问的，因此URL语法会随方案的不同而有所不同。大部分URL都遵循通用的URL语法，而且不同URL方案的风格和语法都有不少重叠。大多数URL方案的URL语法都建立在这个由9部分构成的通用格式上：

~~~
<scheme>://<user>:<password>@<host>:<port>/<path>; <params>?<query>#<frag>
~~~

几乎没有哪个URL包含了所有这些组件。URL最重要的3个部分是方案、主机和路径。见下表：

| 组件 | 描述                                                         | 默认值       |
| ---- | ------------------------------------------------------------ | ------------ |
| 方案 | 访问服务器获取资源时的协议                                   | 无           |
| 用户 | 某些方案访问资源时需要的用户名                               | 匿名         |
| 密码 | 用户名后面可能要包含的密码，中间用冒号分隔                   | E-mail地址   |
| 主机 | 资源宿主服务器的主机名或IP地址                               | 无           |
| 端口 | 资源宿主服务器正在监听的端口号，很多方案都有默认的端口号，比如HTTP的默认是80 | 每个方案特有 |
| 路径 | 服务器上资源的本地名，由一个斜杠将其与前面的URL组件分隔开来。 | 无           |
| 参数 | 某些方案会用这个组件来指定输入参数。参数为`名/值对`。URL中可以包含多个参数字段，他们之间以及路径用分号分隔 | 无           |
| 查询 | 某些方案会用这个组件传递参数已激活应用程序，查询组件内用没有通用格式，用字符？将其与URL其余部分分割开来 | 无           |
| 片段 | 一小片或一部分资源的名字，引用对象时，不会将frag字段传送给服务器，这个字段是在客户端内部使用的，通过#将其与URL其余部分分隔开来。 | 无           |

1. 方案:方案实际上是规定如何访问指定资源的主要标识符，它会告诉负责解析URL的应用程序应该使用什么协议。方案组件必须以一个字母符号开始，由第一个“:”符号将其与URL的其余部分分隔开来。方案名是大小写无关的，因此URL`http://www.demo.com`和`HTTP://www.demo.com`是等价的。

2. 主机与端口：主机组件标识了因特网上能够访问资源的宿主机器。可以用主机名（`www.demo.com`），或者IP地址来表示主机名。端口组件标识了服务器正在监听的网络端口。对下层使用了TCP协议的HTTP来说，默认端口号为80。

3. 用户和密码组件：很多服务器都要求输入用户名和密码才会允许用户访问数据。FTP服务器就是这样一个常见的实例。这里有几个例子：

   比如`ftp://ftp.demo.edu/pub/gnu`此例子没有用户或密码组件，只有标准的方案、主机和路径。如果某应用程序使用的URL方案要求输入用户名和密码，比如FTP，但用户没有提供，它通常会插入一个默认的用户名和密码anonymous（匿名用户）作为你的用户名，并发送一个默认的密码（Internet Explorer会发送IEUser, Netscape Navigator则会发送mozilla）。

   再比如`ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu`这个anonymous的用户名与主机组件组合在一起，看起来就像E-mail地址一样。字符“@”将用户和密码组件与URL的其余部分分隔开来。

   再来看`ftp://anonymous:my passwd@ftp.demo.edu/pub/gnu`此例子指定了用户名（anonymous）和密码（my passwd），两者之间由字符“:”分隔。

4. URL的路径组件：路径说明了资源位于服务器的什么地方。路径通常很像一个分级的文件系统路径。比如：`http://www.demo.com:80/seasonal/index-fall.html`这个URL中的路径为`/seasonal/index-fall.html`，很像UNIX文件系统中的文件系统路径。

   路径是服务器定位资源时所需的信息。可以用字符“/”将HTTP URL的路径组件划分成一些路径段（path segment）。每个路径段都有自己的参数（param）组件。

5. 参数：负责解析URL的应用程序需要这些协议参数来访问资源。否则，另一端的服务器可能就不会为请求提供服务，或者更糟糕的是，提供错误的服务。比如，像FTP这样的协议，有两种传输模式，二进制和文本形式。你肯定不希望以文本形式来传送二进制图片，这样的话，二进制图片可能会变得一团糟。

   为了向应用程序提供它们所需的输入参数，以便正确地与服务器进行交互，URL中有一个参数组件。这个组件就是URL中的名值对列表，由字符“; ”将其与URL的其余部分（以及各名值对）分隔开来。它们为应用程序提供了访问资源所需的所有附加信息。比如：`ftp://ftp.demo.edu/pub/gnu; type=d`在这个例子中，有一个参数type=d，参数名为type，值为d。

   HTTP URL的路径组件可以分成若干路径段。每段都可以有自己的参数。比如：`http://www.demo.com/hammers;sale=false/index.html;graphics=true`这个例子就有两个路径段，hammers和index.html。hammers路径段有参数sale，其值为false。index.html段有参数graphics，其值为true。

6. 查询字符串：很多资源，比如数据库服务，都是可以通过提问题或进行查询来缩小所请求资源类型范围的。

   我们来看一个URL：`http://www.demo.com/check.do?item=12731`这个URL的大部分都与我们见过的其他URL类似。只有问号（?）右边的内容是新出现的。这部分被称为查询（query）组件。URL的查询组件和标识网关资源的URL路径组件一起被发送给网关资源。基本上可以将网关当作访问其他应用程序的访问点。

   按照常规，很多网关都希望查询字符串以一系列“名/值”对的形式出现，名值对之间用字符“&”分隔。比如`http://www.demo.com/check.do?item=12731&color=blue`在这个例子中，查询组件有两个名/值对：item=12731和color=blue。

7. 片段：有些资源类型，比如HTML，除了资源级之外，还可以做进一步的划分。比如，对一个带有章节的大型文本文档来说，资源的URL会指向整个文本文档，但理想的情况是，能够指定资源中的那些章节。为了引用部分资源或资源的一个片段，URL支持使用片段（frag）组件来表示一个资源内部的片段。比如，URL可以指向HTML文档中一个特定的图片或小节。片段挂在URL的右手边，最前面有一个字符“#”。比如：`http://www.demo.com/tools.html#drills`在这个例子中，片段drills引用了Demo的Web服务器上页面/tools.html中的一个部分。这部分的名字叫做drills。

### 1.2.2 HTTP协议的报文

如果说HTTP是因特网的信使，那么HTTP报文就是它用来搬东西的包裹了。HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”及“下游”都是用来描述报文方向的。

> 不管是请求报文还是响应报文，所有报文都会向下游流动。所有报文的发送者都在接收者的上游。

HTTP报文由起始行（start line）、首部（header）块，以及可选的、包含数据的主体（body）三部分组成。

所有的HTTP报文都可以分为两类：请求报文（request message）和响应报文（response message）。

#### 报文的语法

所有的HTTP报文都可以分为两类：请求报文和响应报文。请求报文会向Web服务器请求一个动作。响应报文会将请求的结果返回给客户端。请求和响应报文的基本报文结构相同

请求报文格式：

~~~
<method> <request-URL> <version>
<headers>
<entity-body>
~~~

响应报文格式：

~~~
<version> <status> <reason-phrase>
<headers>
<entity-body>
~~~

- method（方法）

  客户端希望服务器对资源的动作，常见的有GET、POST

- 请求URL（request-URL）

  命名了资源的URL路径

- 版本（version）

  报文所使用的HTTP版本，格式：`HTTP/<major>.<minor>`例如：`HTTP /1.1`

- 状态码（status）

  三位数字用于描述请求过程中发生的情况

- 原因短语（reason-phrase）

  数字状态码的可读版本，包含行终止序列之前的所有文本

- 头部（header）

  可以有零个或多个首部，每个首部包含一个名字跟着一个冒号，跟着一个可选的空格，跟着一个值，最后是一个CRLF（空行）

- 主体部分（entity-body）

  实体的主体部分包含由一个任意数据组成的数据块。并不是所有的报文都包含主体部分

#### 报文的组成

**起始行**

所有的HTTP报文都以一个起始行作为开始。其中包括请求行和响应行。

请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为请求行，包含了一个方法和一个请求URL，这个方法描述了服务器应该执行的操作，请求URL描述了要对哪个资源执行这个方法。

响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为响应行，包含了响应报文使用的HTTP版本、数字状态码，以及描述操作状态的文本形式的原因短语。

请求的起始行以方法作为开始，常见的方法如下：

| 方法    | 描述                                               | 是否包含主体 |
| ------- | -------------------------------------------------- | ------------ |
| GET     | 从服务器获取一份文档                               | 否           |
| HEAD    | 只从服务器获取文档首部                             | 否           |
| POST    | 向服务器发送需要处理的数据                         | 是           |
| PUT     | 将请求的主体存储在服务器上                         | 是           |
| TRACE   | 瑞可能经过代理服务器传送到服务器上去的报文机型追踪 | 否           |
| OPTIONS | 决定可以在服务器上执行哪些方法                     | 否           |
| DELETE  | 从服务器上删除文档                                 | 否           |

方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。常见的状态码：

| 整体范围 | 已定义范围 | 分类       |
| -------- | ---------- | ---------- |
| 100-199  | 100-101    | 信息提示   |
| 200-299  | 200-206    | 成功       |
| 300-399  | 300-305    | 重定向     |
| 400-499  | 400-415    | 客户端错误 |
| 500-599  | 500-505    | 服务器错误 |

原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解释。比如，在行HTTP/1.0200 OK中，OK就是原因短语。原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者将其传送给用户，用以说明在请求期间发生了什么情况

**首部**

跟在起始行后面的就是零个、一个或多个HTTP首部字段。HTTP首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名/值对的列表。例如Content-length:19。具体的详细的首部信息可以自行查阅。

首部和方法配合工作，共同决定了客户端和服务器能做什么事情，首部可以主要分为五种类型：

- 通用首部

  这些是客户端和服务器都可以使用的通用首部。可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能。比如，Date首部就是一个通用首部：

  ~~~
  Date: Tue, 3 Oct 1999 02:17:03 GMT
  ~~~

- 请求首部

  请求首部是请求报文特有的。它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据,例如下面Accept首部就用来告知服务器客户端会接受与其请求相符的任意媒体类型:

  ~~~
  Accept： */*
  ~~~

- 响应首部

  响应报文有自己的首部集，以便为客户端提供信息（比如，客户端在与哪种类型的服务器进行交互）。例如下面Server首部就用来告知客户端它在与openresty服务器进行交互

  ~~~
  server: openresty
  ~~~

- 实体首部

  实体首部指的是用于应对实体主体部分的首部。比如，可以用实体首部来说明实体主体部分的数据类型。例如下面Content-Type首部告知应用程序，数据是以utf-8字符集表示的HTML文档

  ~~~
  Content-Type: text/html; charset=utf-8
  ~~~

- 扩展首部

  扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的HTTP规范中去。即使不知道这些扩展首部的含义，HTTP程序也要接受它们并对其进行转发。

**主体**

HTTP报文的第三部分是可选的实体主体部分。实体的主体是HTTP报文的负荷。就是HTTP要传输的内容。HTTP报文可以承载很多类型的数字数据：图片、视频、HTML文档、软件应用程序、信用卡事务、电子邮件等。

## 1.3 HTTP协议的演进

HTTP1.1之前，由于无状态等特点，每次请求都需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户端在短时间多次请求同一个资源，但是服务器并不能区分是否已经响应过用户的请求，所以每次请求都需要重新响应。为了节省资源消耗，HTTP协议也进行了发展和改进：

| 版本     | 产生时间 | 内容                                                         | 发展状况         |
| -------- | -------- | ------------------------------------------------------------ | ---------------- |
| HTTP/0.9 | 1991     | 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求 | 没有作为正式标准 |
| HTTP/1.0 | 1996     | 传输内容格式不限制，增加PUT、PATCH、HEAD、OPTIONS、DELETE    | 正式作为标准     |
| HTTP/1.1 | 1997     | 持久连接（长连接）、节约带宽、HOST域、管道机制、分块传输协议 | 2015年前广泛使用 |
| HTTP/2.0 | 2015     | 多路复用、服务器推送、头信息压缩、二进制协议等等             | 逐渐覆盖市场     |



## 1.4 基于Netty实现简单的Web服务器

# 二、高并发HTTP的核心原理

# 三、WebSocket原理

# 四、SSL/TLS核心原理