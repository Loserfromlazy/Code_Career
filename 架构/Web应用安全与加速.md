# Web安全与加速学习笔记（未完结）

转载请声明作者和出处！

本文如有错误，欢迎指正，感激不尽。

# 一、HTTP

> 参考资料：HTTP权威指南，互联网博客

## 1.1 HTTP报文

如果说HTTP是因特网的信使，那么HTTP报文就是它用来搬东西的包裹了。HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”及“下游”都是用来描述报文方向的。

> 不管是请求报文还是响应报文，所有报文都会向下游流动。所有报文的发送者都在接收者的上游。

HTTP报文由起始行（start line）、首部（header）块，以及可选的、包含数据的主体（body）三部分组成。

所有的HTTP报文都可以分为两类：请求报文（request message）和响应报文（response message）。

### 1.1.1 报文的语法

所有的HTTP报文都可以分为两类：请求报文和响应报文。请求报文会向Web服务器请求一个动作。响应报文会将请求的结果返回给客户端。请求和响应报文的基本报文结构相同

请求报文格式：

~~~
<method> <request-URL> <version>
<headers>
<entity-body>
~~~

响应报文格式：

~~~
<version> <status> <reason-phrase>
<headers>
<entity-body>
~~~

- method（方法）

  客户端希望服务器对资源的动作，常见的有GET、POST

- 请求URL（request-URL）

  命名了资源的URL路径

- 版本（version）

  报文所使用的HTTP版本，格式：`HTTP/<major>.<minor>`例如：`HTTP /1.1`

- 状态码（status）

  三位数字用于描述请求过程中发生的情况

- 原因短语（reason-phrase）

  数字状态码的可读版本，包含行终止序列之前的所有文本

- 头部（header）

  可以有零个或多个首部，每个首部包含一个名字跟着一个冒号，跟着一个可选的空格，跟着一个值，最后是一个CRLF（空行）

- 主体部分（entity-body）

  实体的主体部分包含由一个任意数据组成的数据块。并不是所有的报文都包含主体部分

### 1.1.2 报文的组成

**起始行**

所有的HTTP报文都以一个起始行作为开始。其中包括请求行和响应行。

请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为请求行，包含了一个方法和一个请求URL，这个方法描述了服务器应该执行的操作，请求URL描述了要对哪个资源执行这个方法。

响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为响应行，包含了响应报文使用的HTTP版本、数字状态码，以及描述操作状态的文本形式的原因短语。

请求的起始行以方法作为开始，常见的方法如下：

| 方法    | 描述                                               | 是否包含主体 |
| ------- | -------------------------------------------------- | ------------ |
| GET     | 从服务器获取一份文档                               | 否           |
| HEAD    | 只从服务器获取文档首部                             | 否           |
| POST    | 向服务器发送需要处理的数据                         | 是           |
| PUT     | 将请求的主体存储在服务器上                         | 是           |
| TRACE   | 瑞可能经过代理服务器传送到服务器上去的报文机型追踪 | 否           |
| OPTIONS | 决定可以在服务器上执行哪些方法                     | 否           |
| DELETE  | 从服务器上删除文档                                 | 否           |

方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。常见的状态码：

| 整体范围 | 已定义范围 | 分类       |
| -------- | ---------- | ---------- |
| 100-199  | 100-101    | 信息提示   |
| 200-299  | 200-206    | 成功       |
| 300-399  | 300-305    | 重定向     |
| 400-499  | 400-415    | 客户端错误 |
| 500-599  | 500-505    | 服务器错误 |

原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解释。比如，在行HTTP/1.0200 OK中，OK就是原因短语。原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者将其传送给用户，用以说明在请求期间发生了什么情况

**首部**

跟在起始行后面的就是零个、一个或多个HTTP首部字段。HTTP首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名/值对的列表。例如Content-length:19。具体的详细的首部信息可以自行查阅。

首部和方法配合工作，共同决定了客户端和服务器能做什么事情，首部可以主要分为五种类型：

- 通用首部

  这些是客户端和服务器都可以使用的通用首部。可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能。比如，Date首部就是一个通用首部：

  ~~~
  Date: Tue, 3 Oct 1999 02:17:03 GMT
  ~~~

- 请求首部

  请求首部是请求报文特有的。它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据,例如下面Accept首部就用来告知服务器客户端会接受与其请求相符的任意媒体类型:

  ~~~
  Accept： */*
  ~~~

- 响应首部

  响应报文有自己的首部集，以便为客户端提供信息（比如，客户端在与哪种类型的服务器进行交互）。例如下面Server首部就用来告知客户端它在与openresty服务器进行交互

  ~~~
  server: openresty
  ~~~

- 实体首部

  实体首部指的是用于应对实体主体部分的首部。比如，可以用实体首部来说明实体主体部分的数据类型。例如下面Content-Type首部告知应用程序，数据是以utf-8字符集表示的HTML文档

  ~~~
  Content-Type: text/html; charset=utf-8
  ~~~

- 扩展首部

  扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的HTTP规范中去。即使不知道这些扩展首部的含义，HTTP程序也要接受它们并对其进行转发。

**主体**

HTTP报文的第三部分是可选的实体主体部分。实体的主体是HTTP报文的负荷。就是HTTP要传输的内容。HTTP报文可以承载很多类型的数字数据：图片、视频、HTML文档、软件应用程序、信用卡事务、电子邮件等。

## 1.2 连接管理

世界上几乎所有的HTTP通信都是由TCP/IP承载的，TCP/IP是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。客户端应用程序可以打开一条TCP/IP连接，连接到可能运行在世界任何地方的服务器应用程序。一旦连接建立起来了，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或失序。

### 1.2.1 TCP连接

HTTP连接实际上就是TCP连接及其使用规则。TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序、正确地传送出来，如下图：

![TCP连接20220225](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/TCP%E8%BF%9E%E6%8E%A520220225.png)

TCP的数据是通过名为IP分组（或IP数据报）的小数据块来发送的。HTTP就是“HTTP over TCP over IP”这个“协议栈”中的最顶层了。其安全版本HTTPS就是在HTTP和TCP之间插入了一个（称为TLS或SSL的）密码加密层。

![image-20220225090743967](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220225090743967.png)

HTTP要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输。TCP收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在IP分组中，通过因特网进行传输。

![image-20220225091241338](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/image-20220225091241338.png)

TCP通过四个值定义了一条连接。两条不同的TCP连接不能拥有4个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值），这四个值是`<源IP地址、源端口号、目的IP地址、目的端口号>`

### 1.2.2 TCP连接的建立和销毁

在两个设备要建立连接发送数据之前，双方都需要做一些准备工作

1. 最开始客户端和服务器处于CLOSE状态。客户端主动打开连接，服务器被动打开连接。TCP服务器创建传输控制块TCB，时刻接收客户端的连接请求，此时服务器进入LISTEN状态

2. 一次握手

   Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server， Client进入SYN_SENT状态，等待Server确认。

3. 二次握手

   Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位 SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求 ，Server进入SYN_RCVD状态。

4. 三次握手

   Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK 置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则 连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以 开始传输数据了。

   ![TCP三次握手20220225](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B20220225.png)

而终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。

- **第一次挥手**：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入 FIN_WAIT_1状态
- **第二次挥手**：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同， 一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
- **第三次挥手**：Server等待2MSL（MSL）后发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK 状态。
- **第四次挥手**：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

![TCP四次挥手20220225](https://mypic-12138.oss-cn-beijing.aliyuncs.com/blog/picgo/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B20220225.png)

> 为什么挥手是四次？因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里 发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还 能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些 数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会 分开发送。

> SYN flood攻击原理
>
> DDOS是分布式拒绝服务，本质是利用合理的请求造成服务器资源过载，造成服务不可用，常见的DDOS攻击有SYN flood等 。
>
> SYN flood在攻击时，首先伪造大量的源IP地址，分别向服务器端发送大量的SYN包。服务器端返回SYN/ACK，因为源地址是伪造的所以不会应答，服务器没有收到应答就会重试3-5次。攻击者大量发送这种请求，服务器就会消耗很多请求，同时还有对他们进行重试因此到最后服务器服务无法处理正常请求导致拒绝服务。







